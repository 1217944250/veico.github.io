## 概述

JavaScript：简称JS,是一个运行在客户端浏览器的【解释型】【弱类型】【面向对象】脚本语言

1.	编译型：在运行程序之前，需要先检查语法是否正确，如果不正确，直接不允许运行- 严格,不如：java/c++/c#...

​	    解释型：在运行程序之前，不需要先检查语法是否正确，直接运行，但是遇到错误后停止运行后续代码

2. 弱类型：变量保存的数据是可以随意的，数据类型是由数据来决定的 -更加的自由

​       强类型：变量保存的数据，是由数据类型来决定的  -Java -更加的严格

3.特点：

​			2.解释型

​			3.弱类型

​			4.面向对象编程方式

​			5.可以做一切css完成不了的效果

## 组成

JavaScript其实由三部分组成

ECMAScript - 核心语法

DOM - Document  Object Model -文档对象模型，可以用js 来操作HTML和CSS

BOM - Browser Object Model - 浏览器对象模型，可以操作浏览器

## 如何使用JS

### 使用方式

​	1.使用方式：2种

​				1.直接在html页面上写一个script标签，里面就可以书写js代码

```
<script></script>
```

​				2.外部JS,进行引入 - 正式开发时使用

```
1)创建xx.js，里面书写js代码
2)在html页面引入
	<script src="js文件路径">
		只要有了src属性，此处就不可以在写代码了
	</script>
```

### 输出方式	

2.输出方式：帮助我们检查错误：3种

​			1、在控制台输出日志：

```
console.log(想要输出/查看的东西)
```

​			2、在页面上输出日志：

-缺点:如果绑定了点击事件，则之前的html+css消失了

-在页面上输出，而且支持识别标签

```
document.write(想要输出/查看的东西)
```

​			3、在弹出框输出日志：

-在浏览器自带的弹出框输出日志，但是弹出框会卡住页面，用户看到的只是白板

```
alert(想要输出/查看的东西)
```

### *变量和常量

​	*变量：创建后，值可以再次修改

​	何时使用：以后反复使用到的数据，都要提前把他保存在一个变量中，以后使用变量名，相当于就是在使用变量的值

​	如果使用：

```
var 变量名 = 值;
```

​	特殊：

​		1.变量名其实不是随意的

```
1.变量名其实不是随意的
2.不能以关键字命名
3.建议下划线命名法 或 小驼峰命名法
```

​		2.如果你的变量名是name，不管你保存的数据是什么数据类型，都会悄悄转换成字符串

​		3.多个变量创建可以简写：
​				var 变量名=值1，变量名=值2...;

​	常量：创建后，值不可以再次修改，只能设置一次值	

```
const 常量名 = 值;
```

### *算术运算符：+ - * / % 

​	1.%：读作取余，俗称模，两个数相除，不去商，而取除不尽的余数

​			固定套路：

​			1、判断奇偶性

​			2.获取一个数字的倒数n位

​	2.***特殊：其实算数运算符具有隐式类型转换，默认转为数字在运算

​			+运算：如果左右两边单反出现一个字符串，那么悄悄的转为字符串，+运算不再是+运算，而是拼接

​			- * / %：字符串也可以变为数字，但必须是纯数字组成的字符串 如果字符串包含了非数字字符，直接转为NaN: Not A Number (不是一个数但是是数字类型)



### *数据类型

原始/基本/值类型：5个

​		1、Number - 数字，取值：无数个

​		2、String - 字符串，取值：无数个，必须写上"" 或''

​		3、Boolean - 布尔 ，取值：两个：true/false -往往用于判断比较的条件处使用

​		4、Undefined - 取值：一个：undefined，创建了一个变量，但是没有赋值，默认值为undefined(祖师爷犯的错，用来做大部分操作都会报错！)

​		5、Null - 空 取值：1个：null，释放变量/内存，节约内存空间

引用/对象类型：11个引用类型的对象(很多很多的属性和方法)

### 分支结构

判断条件的不同选择对应的代码去执行，执行力一条路就不会再走别的路

#### 如何使用

​		一个条件，一件事，满足就做，不满足就不做

```
		if(判断条件){
			操作；
		}
```

​		一个条件，一件事，满足就做，不满足就做第二件

```
		if(判断条件){
        操作1；
		}else{
			操作2；
		}
```

​		多个条件，多件事，满足谁就做谁

```
		if(判断条件){
			操作1；
		}else if{
			操作2；
		}else{
			操作3；
		}
```

特殊：

​	1、else if...你想写多少个随便，根据你的需求自己判断

​	2、最后的else可以省略不写，如果条件都不满足，那么什么事都不会执行，分支白写

​	3、书写判断顺序，需要根据你的需求来写，不能乱写顺序

### 用户输入弹出框

```
var 变量名 = prompt("提示文字","默认值")
```

## 数据类型转换

不同的数据类型做操作可能出来的结果是不一样的

​	Number + Number = Number

​	Number + String = String

js获取页面上的一切东西，数据类型默认都是一个字符串

如果你想要查看数据类型：

```
typeof(想要查看的东西);
```

### 算数运算符的隐式转换

默认：算数运算符具有隐式类型转换，默认转为数字在运算

特殊：

​	1、+运算：如果左右两边单反出现一个字符串，那么悄悄的转为字符串，+运算不再是+运算，而是拼接

​	2、别的数据类型其实也可以转为数字

​			true->1   false->0    null->0     undefined->NaN

​	3、其实- * / %，字符串也可以转为一个数字，前提是一个纯数字组成的字符串

​	4、NaN: Not A Number：不是一个数字，但是确实是数据类型，不是一个有效数字

​			NaN的特点：

​			1.参与任何运算都是NaN

​			2.参与任何比较都是false

#### 如果判断NaN

​	问题：我们没有办法使用普通的比较方法判断数据是不是NaN

​	解决：

```
isNaN(x)
	true->是一个有效数字
	false->是一个无效数字
```

### 显示/强制转换

隐式转换出来的结果不是我们想要的，我们程序员就要手动调用一些方法，强制转为我们需要的类型，再做操作

#### 转字符串

```
var str=x.toString();//x不能是undefined或null，因为undefined和null不能使用任何的操作页面上的一切东西，数据类型默认都是一个字符串
```

#### 转数字

```
方法一:parseInt(str/num);  parse->解析 Int->整型
```

执行原理:专门为字符串和小数转为整数数字准备的，从左向右依次读取每个字符，碰到非数字字符，就停止转换，如果一来就碰到不认识的，则为NaN

```
方法二:parseFloat(str);  parse->解析 float->浮点型
```

执行原理:几乎和parseInt一致，认识第一个小数点

```
方法三:Number(x) 
```

此方法是万能的，任何人都可以转为数字。。完全等效于隐式转换

## Function基础

函数，陈志文方法:需要提前【预定义】好，以后可以【反复使用】的【代码段】

### 如何使用

#### 1.定义/声明/创建函数

```
function 函数名(){	
	代码块
}
```

#### 2.调用/使用函数

```
1.要么在js中程序员直接写死，要执行几次:函数名()
2.交给用户绑定在某个元素上，写上点击事件，让用户来触发:
	<elem onclick="js代码">内容</elem>
```

#### 3.何时使用

1.不希望打开页面立刻执行，而需要是再使用 或 由用户来触发
2.希望能够反复执行，不用刷新页面

3.以后任何一个独立的功能体，都要单独封装为一个函数

4.封装函数yyds

5.函数内的一切内存，函数调用完毕后都会自动释放

#### 4.带参数的函数

函数   参数

创建：形参：形式参数，其实就是一个变量，但是不需要写var，而且默认也没有保存任何值，默认值为undefined

```
function 函数名(形参,形参...){	
	函数体
}
```

使用：实参：实际参数，真正的值，需要再调用时再传入

```
函数名(实参,实参...)
```

特殊:1、传实参的顺序一定要和形参的顺序一一对应，并且数量也要对应
2、不是一定要带参数的函数才是好函数，具体情况，需要具体分析:
	如果你的函数体就是固定的-则普通函数
	如果你的函数体希望根据传入的实参不同，做的略微不同–则带有参数的函数

### 分支结构

#### 程序的流程控制语句:3种

1.顺序执行 - 默认,从上向下的依次执行

2.分支结构 - 通过条件的判断，选择部分代码执行

3.循环结构 - 通过条件的判断，选择要不要重复执行某些代码

#### 比较运算符

<  >   <=  >=  ==   !=

用于做判断/比较的

结果:一定是个布尔值

强调：如果你想要判断多个条件，绝对不能像小时候数学的写法：区间写法

#### 逻辑运算符

&&：与    -要求全部条件满足最后结果才为true，否则为false

||：或 	-要求全部条件不满足最后结果才为false，否则为true

！：颠倒布尔值

## 循环结构

反复执行【相同 或 相似】的操作

​	循环三要素：

​		1.循环条件：开始 - 结束，循环的次数

​		2.循环体：做的操作是什么

​		3.循环变量：记录着我们当前在哪一次，而且他会不断的变化，往往都会向着不满足循环条件进行

### while循环

```
var 循环变量=
while(循环条件){
	循环体;
	循环变量变化
}
```

执行原理：首先创建了循环变量，然后判断条件，如果条件满足，则做【一次】循环体操作，并不会退出循环，回头继续判断条件满足吗，如果满足，则再做【一次】直到循环条件不满足，再退出循环

宏观上感受循环一瞬间就结束了，但是微观上其实是【一次一次】执行的

特殊：

1、有的时候真可能不知道从何开始，到何处结束，死循环：永远不会停下

```
while(true){
	循环体;
}
```

2、退出循环语句：break - 只能在循环中使用，多半都是搭配死循环使用的

随机数公式：

```
parseInt(Math.random()*(max-min+1)+min)
```

### for循环

```
for(var 循环变量=x; 循环条件;变量的变化){
	循环体
}
```

同时支持死循环

```
for(;;){
}
```

面试题：while 和 for 的区别？

​		语法上有区别，但两者都能做到相同的操作

​		一般来说我们不确定循环次数的时候，会使用while死循环

​		一般来说我们确定循环次数的时候，会使用for循环

## 数组基础

变量其实就是我们的内存， 变量创建的越多，我们内存空间消耗越大，那么网站的性能就越差

数组：创建一个变量可以保存【多个数据】的集合

​	数组都是线性排列，除了第一个元素，每个元素都有唯一的前驱元素

​	除了最后一个元素，每个元素都有唯一的后继元素

每个元素都有自己的位置。称之为下标，下标从0开始，到最大长度-1

### 创建数组：2种

1、直接量数组

```
var arr=[];//空数组  其实[]的方式是ES3才带来的，原来只有用new Array才能创建数组
var arr=[数据1，数据2...];
```

2、构造函数方式

```
var arr=new Array();
```

### 获取数组的数据

```
数组名[下标];
```

### 添加/替换

```
数组名[下标]=新值;
下标处有没有元素，如果没有则为添加，如果有了就替换
```

### 数组三大不限制

1、不限制元素个数

2、不限制元素类型

3、不限制元素的下标越界

​		如果获取元素，下标越界，返回的一个undefined

​		如果添加元素，下标越界，会得到一个稀疏数组，导致下标不再连续，如果搭配上循环去遍历每一个元素的话，我们会得到很多很多的undefined



解决：数组中唯一的属性：长度-获取当前数组的长度：最大下标+1

```
数组名.length
```

固定方法：

1、获取倒数第n个元素：

```
arr[arr.length-n];
```

2、始终向末尾添加元素：

```
arr[arr.length]=新值;
```

3、缩容：删除倒数n个元素

```
arr.length-=n;
```

往往很多情况，我们不会拿出某个元素来使用，而是拿出所有的每个元素来进行相同或相似的操作

### 遍历数组

```
for(var i=0;i<数组名.length;i++){
	console.log(数组名.[i])
}
```

## DOM

文档对象模型：专门用于操作HTML文档的，提供一些属性和方法等待我们学习

### DOM树概念

DOM将我们的HTML看作是一个倒挂的树状结构，但是树根不是html标签，而是document对象

document对象是由浏览器js解释器自动生成的，一个网页只有一个document

作用：可以通过树根找到我们想要的任何一个DOM元素/节点/对象(属性和方法)

DOM会将页面上的每一个元素、属性、文本、注释都会当作一个DOM元素/节点/对象

### 查找元素

#### 通过ID查找元素

```
var elem=document.getElementById("id值")
特殊：
	1、返回值，找到了返回的是一个找到的DOM元素，没找到返回值是null
	2、找到多个相同的id，也只会返回第一个
	3、垃圾方法，一次只能操作一个
	4、其实根本不需要使用此方法，直接写ID也可以找到元素 - 偷懒的写法
```

#### 通过标签名查找元素

```
var elem=document/已经找到的父元素.getElementByTagName("标签名")
特殊：
	1、返回值：找到了返回的是一个类数组DOM集合(很想数组，都能用下标，都能用length，都能遍历)，没找到返回一个空集合
	2、*js不能直接操作DOM元素集合，只能直接操作DOM元素
		解决：要么使用下标拿到某一个元素，要么使用遍历拿到每一个元素
	3、不一定非要从document开始查找，如果document去找，会找到所有元素，可以换成我们已经找到的某个父元素，就只会找到这个父元素下面的元素
```



#### 通过class名查找元素

```
var elem=document/已经找到的父元素.getElementByClassName("标签名")
特殊：
	1、返回值：找到了返回的是一个类数组DOM集合(很想数组，都能用下标，都能用length，都能遍历)，没找到返回一个空集合
	2、*js不能直接操作DOM元素集合，只能直接操作DOM元素
		解决：要么使用下标拿到某一个元素，要么使用遍历拿到每一个元素
	3、不一定非要从document开始查找，如果document去找，会找到所有元素，可以换成我们已经找到的某个父元素，就只会找到这个父元素下面的元素
```

#### 通过关系查找元素

前提条件：必须先找到一个元素才可以调用关系网

```
父元素：elem.parentNode
子元素：elem.children
第一个儿子：elem.firstElementChild
最后一个儿子：elem.lastElementChild
前一个兄弟：elem.previousElementSibling
后一个兄弟：elem.nextElementSibling
```

### 操作元素

前提：找到元素才能操作元素：

```
<标签 属性名="属性名" style="样式">内容</标签>
```

#### 1、内容

​	1、innerHTML: 获取 和 设置 开始标签到结束标签之间的内容 - 支持识别标签

```
	获取: elem.innerHTML;
	设置:elem.innerHTML="新内容";
```

​	2、innerText: 获取 和 设置 开始标签到结束标签之间的文本 -不支持识别标签

```
	获取: elem.innerText;
	设置:elem.innerText="新内容";
```

​	以上两个属性都是为双标签准备的，但是操作不了单标签input的内容

​	3、value:专门为input的value值准备的

```
	获取: input.value;
	设置:input.value="新内容";
```

#### 2、属性

```
	获取属性值:elem.getArrtibute("属性名");
	设置属性值:elem.getArrtibute("属性名","属性值");
	
	简化版：
	获取属性值:elem.("属性名");
	设置属性值:elem.属性名="新属性值";
			缺陷：
				1.class必须写为className -2015年过后，ES6诞生过后，class变成一个关键字
				2.不能操作自定义属性，只能操作标准属性
```

#### 3、样式

```
	获取/设置属性值:elem.style.css属性名="css属性值";
	特殊：
		1、css属性名，有横线的地方，去掉横线，变为小驼峰命名法
			border-radius -> borderRadius
		2、目前学习的，获取时，只能获取内联样式
```

#### 4.绑定事件

```
	elem.on事件名=function(){
			操作;
			this关键字：目前只能用于事件内;
					如果单个元素绑定事件:this->这个元素
					如果多个元素绑定事件:this->当前
	}
```

总结：

​	获取 --往往都是用于判断，比较

​	设置 --就是修改/添加


计算字符串：脱掉字符串的外套

```
eval("")
```

eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。

如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。

![](https://1217944250.github.io/veicos.github.io/imgs/1.png)
## 数据类型转换

### 强制转换

#### 转字符

```
var str=x.toString();
```

#### 转数字

```
方法一:parseInt(str/num);  parse->解析 Int->整型
```

执行原理:专门为字符串和小数转为整数数字准备的，从左向右依次读取每个字符，碰到非数字字符，就停止转换，如果一来就碰到不认识的，则为NaN

```
方法二:parseFloat(str);  parse->解析 float->浮点型
```

执行原理:几乎和parseInt一致，认识第一个小数点

```
方法三:Number(x) 
```

此方法是万能的，任何人都可以转为数字。。完全等效于隐式转换

#### 转布尔

```
Boolean();
只有六个会为false
Boolean(0);
Boolean("");
Boolean(undefined);
Boolean(null);
Boolean(NaN);
Boolean(flase);
```

## 运算符和表达式

### 算数运算符

 + - * /  %



### 比较运算符

<  >   <=  >=  ==   !=  ===   !===

用于做判断/比较的

结果:一定是个布尔值

隐式转换：转成数字再比较

特殊：

​	1.如果参与比较的左右两边都是字符串，则按位pk每个字符的十六进制的unicode号(十进制ASCII码)

​	ACSII码顺序	0-9<A-Z<a-z<汉字

​	2.NaN参与任何比较运算结果都为false，所以没有办法使用普通的比较运算来判断x是不是NaN

```
!isNaN(x);
```

​	3.undefined==null;//true

区分：undefined===null;

全等：=== -要求数值相同，并且数据类型也要相同，不再带有隐式转换

!== - 不再带有隐式转换的不等比较

### 逻辑运算符

作用：综合比较，结果也是布尔值

隐式转换：左右两边都会悄悄转为布尔值，再综合比较结果

&&：与    -要求全部条件满足最后结果才为true，否则为false

||：或 	-要求全部条件不满足最后结果才为false，否则为true

！：颠倒布尔值

特殊：短路逻辑：如果前一个条件，已经可以得出最终结果了，没有必要看后续

#### &&短路

​	&&短路：如果前一个条件满足，才执行后一个条件，如果前一个条件不满足，则不管后续条件

​		目的：简化简单的分支：1、一个条件一件事，满足就做，不满足就不做	2、操作只能有一句话：多句操作导致我们以后维护目的观看

​		语法：

```
条件&&(操作);
```

#### ||短路

实现浏览器兼容性问题：二选一

​	e=e || window.event；

### 位运算

左移：m<<n,读作m左移了n位

左移：m>>n,读作m右移了n位

### 赋值运算

+= -= *= /= %= ++ --

​	一句话完成两个操作，先计算，在赋值回去

##### 【面试题】

i++ 和++i的区别

单独使用时，放前放后无所谓效果一样
但是如果参与了别的表达式，变量中的值都会＋1
前++【返回的是加了过后】的新值

后++【返回的是加了过前】的旧值

### 三目运算

简化if...else...     if...else if...else

三目运算符：又称之为三元[运算符](https://so.csdn.net/so/search?q=运算符&spm=1001.2101.3001.7020)

格式：

```
(关系表达式)?表达式1:默认操作;
(关系表达式1)?表达式1:(关系表达式2)?表达式2:默认操作;
```

如果关系表达式的结果为true，运算后的结果是表达式1；

如果关系表达式的结果为false，运算后的结果是表达式2；

### 拓展

1、四舍五入

解决：num.toFixed(d)d代表保留小数位，会四舍五入

缺陷：返回的是要字符串，建议搭配parseFloat食用

2、

### 获取字符串中第一个字符的ASCII码

```
elem.charCodeAt(0);
```



## 函数

也叫做方法，是需要预定义好的，以后可以反复使用的代码段

### 创建函数并且调用

#### 声明方式创建函数

用一个关键字function做声明

```
	function 函数名(形参列表){
		函数体;
		return 返回值;
	}
```

调用函数：函数名(实参列表)

#### 直接量方式创建函数

函数名其实就是一个变量名

	var 函数名=function(形参列表){
		函数体;
		return 返回值;
	}

### 作用域

#### 全局作用域

全局变量和全局函数，在任何地方都可以使用

#### 函数/局部作用域

局部变量和局部函数，在【函数调用】时内部可用

<font color="red">带来了变量的使用规则:优先使用局部的，局部没有找全局，全局没有就报错</font>

#### 声明提前(笔试重点)

真正开发不会用

原理：

在程序正式执行之前，

会将var声明的变量和function声明的函数，

集中提前到当前作用域的顶部，

变量比函数轻，但是赋值留在原地



### 按值传递

两个变量之间进行赋值

如果传递的是原始类型的值

​		修改一个变量，另一个变量是不会收到影响到，其实是复制了一个【副本】给对象

如果传递的是引用类型的对象：js中 不是原始类型就是引用类型

修改一个变量，另一个变量其实也会受到影响，因为大家操作的其实是同一个【地址值】–浅拷贝

### 编码和解码

```
编码:var code=encodeURIComponent("剑风传奇");
解码: var 原文=decodeURIComponent(code);
```

其实这个东西在某次浏览器更新后，当前就淘汰了!浏览器现在自带此功能

### isFinite(num)

判断num是不是无穷大，true->有效数字，false->无穷大

那些会为false： NaN  Infinity  分母为0，所有有多个都为false，不能用来判断是不是NaN

## 分支结构

swith...case...

语法：

```
switch(变量/表达式){
	case值1:
	操作1;
	case值2:
	操作2;
	default:
	默认操作;
}
```

特殊：

​	1、case的比较是不带隐式转换的

​	2、问题:默认只要一个case满足后，会将后面所有的操作全部做完

​			解决:break;

​			建议：每个case都加上break；

​	有的地方也可以省略break :
​		1、最后的一个操作default可以省略break
​		2、如果中间多个条件，做的操作是一样的，也可以省略掉中间的操作

​	3、default可以省略不写，如果条件都不满足的情况，则什么事都不会执行

#### 【面试题】 if   vs    switch

1、 switch:好处:执行效率相对较高
					缺点:必须要知道最后的结果才能使用，不能做范围判断
2、if:		好处:可以做范围判断

​				  缺点:执行效率相对较低

开发时:用哪个都无所谓
代码优化:尽量的将if换成switch

## 拓展JS动画

几乎和js无关，与css有关(transition过度)

JS操作样式:瞬间生效的，只需要加上过度就会慢慢生效

### animate.css动画库



## 循环结构

### do...while

```
var 循环变量 = 几;
do{
	循环体;
	循环变量的变化;
}while(循环条件)
```

### 【面试题】while和do...while的区别

除了写法上有区别，还有—个点:只看第一次
如果第—次大家都满足，两者其实没区别
如果第一次大家都不满足。while—次都不会执行，而do...while至少会执行—次

建议:优先使用for循环，不确定循环次数的时候再用while补充

## 终止循环语句

break  退出//退出整个循环

continue	继续//退出本次循环，还会继续做下一次

## 数组的基础

一个变量名可以保存多个数据

### 创建数组：2种

1、直接量数组

```
var arr=[];//空数组  其实[]的方式是ES3才带来的，原来只有用new Array才能创建数组
var arr=[数据1，数据2...];
```

2、构造函数方式

```
var arr=new Array();
```

### 【面试题】new Array(3)是什么意思 

创建一个长度为3的空数组

### 获取数组的数据

```
数组名[下标]-某个元素;
```

特殊：读取元素，下标越界 - 返回undefined

​			添加元素，下标越界 -稀疏数组

### 添加/替换

```
数组名[下标]=新值;
下标处有没有元素，如果没有则为添加，如果有了就替换
```

### 数组三大不限制

1、不限制元素个数

2、不限制元素类型

3、不限制元素的下标越界

​		如果获取元素，下标越界，返回的一个undefined

​		如果添加元素，下标越界，会得到一个稀疏数组，导致下标不再连续，如果搭配上循环去遍历每一个元素的话，我们会得到很多很多的undefined



解决：数组中唯一的属性：长度-获取当前数组的长度：最大下标+1

```
数组名.length
```

固定方法：

1、获取倒数第n个元素：

```
arr[arr.length-n];
```

2、始终向末尾添加元素：

```
arr[arr.length]=新值;
```

3、缩容：删除倒数n个元素

```
arr.length-=n;
```

往往很多情况，我们不会拿出某个元素来使用，而是拿出所有的每个元素来进行相同或相似的操作

### 遍历数组

```
for(var i=0;i<数组名.length;i++){
	console.log(数组名.[i])
}
```

释放一个引用类型的对象:切记一定要看清楚这个对象有几个变量关联着，每个变厘都要释放后才能真正的释放

最好的方式就是封装为一个函数，因为函数中的东西，调用完毕会自动释放

### 索引数组

下标都是数字组成的数组-默认

### 关联(hash)数组

下标是可以自定义的数组

为什么要自定义下标:索引数组的下标无具体的意义，不便于我们查找

#### 如果创建

1、先创建一个空数组：var arr=[]；

2、添加自定义下标并且赋值:arr["自定义下标"]=新值;

#### 访问

```
arr["自定义下标"];
```

#### 遍历

问题:不能使用for循环去遍历关联数组，因为length失效了，关联数组的length永远为O，而且我们下标也不再是一个数字

遍历:把数组中的每一个元紊取出来执行相同或相似的操作

解决：for in 循环

​	个人不爱称呼他叫做一个循环，因为不能设置从哪里开始到哪里结束，所有的操作都是自动的

语法：

```
for(var i in数组名){
	i;//自动得到每一个小标
	数组名[i];//当前hash数组中的元索了
}
既可以遍历哈希数组，又可以遍历索引数组
```

JS中除了undefined和null不是一个对象，万物皆对象，而【一切对象的底层都是hash数组】

#### 面试: *hash数组的原理:

hash算法：将字符串交给hash算法，会得到一个尽量不重复的数字，但是字符串的内容相同，那么得到的数字也一定是相同

添加元素：将自定义下标交给hash算法，得到一个数字(地址值)，把要保存的数据放进去

读取元素：将指定的自定义下标交给hash算法，得到一个和添加时完全相同的数字(地址值)，通过这个地址值可以拿到当初保存的东西

## 数组的API

### 数组转字符串

```
var str=arr.join("自定义连接符");
```

特殊：
	1、如果没有传入实参，则和toString效果一致，默认都是用，隔开

​	2、【面试笔试题】无缝连接

```
var arr=["h","e","l","l","o"]
arr.join("")
```

3、***将数组元素拼接为页面元素（数据渲染)

```
/获取数据
var arr=["-请选择-","北京","东京"]
//将数组转为了字符串，并且拼接上了标签
var str=" <optiop>"+arr.join(" </option> <option>")+"</option>";1/让字符串上DOM树, innerHTMIL是识别标签
sel.innerHTML=str;
```

#### 二级联动

1、必须使用二维数组，细分每一个城市，并且二维数组的顺序要和之前的一维数组对应

2、select.onchange=function(){} - 状态改变事件：只有选中项发生变化时，才会触发

3、select可以直接获取当前选中项的下标，而不需要自定义下标，select.selectedIndex

4、其实绑定事件，等号左边部分就是你的函数名

### 拼接数组

添加原始到末尾的新方式

```
var newArr=arr.concat(值1,值2...)
```

特殊：

1、此方法不会修改原数组，必须拿一个变量接住结果(返回一个新数组)

2、哪怕拼接的时一个数组，悄悄的打散数组，单个添加

### 截取子数组

```
var newArr=arr.slice(starti,endi+1)
```

特殊：

1、此方法不会修改原数组，必须拿一个变量接住结果(返回一个新数组)

2、含头不含尾

3、如果只传入了一个实参，则为从Starti开始到末尾

#### <font color=red>深拷贝</font>

4、如果两个实参都省略，则复制了一份 -深拷贝  两者互不影响

5、支持负数参数，-1代表倒数第—个，-n代表倒数第n个

以上的API都是不修改原数组的-------------------------------------以下的API都是修改原数组的

### 删插替 splice

#### 删除

```
arr.splice(starti,n)//从starti位置开始删除
var dels=arr.splice(starti,n)
```

特殊：返回的是你删除的元素组成的数组-有可能你删除的正好是你需要的

#### 插入

```
arr.splice(starti,0,新值1,新值2....)
var newArr=arr.splice(starti,0,新值1,新值2....)
```

特殊:1、原来starti位置的元紊以及后续元系都会被向后移动
2、没有删除元素，也有返回值，返回的是一个空数组而已

#### 替换

```
var newArr=arr.splice(starti,n,新值1,新值2....)
```

特殊：删除的个数和插入的个数不必相同

#### 翻转数组

```
arr.reverse(); -一仅仅只能翻转
```



## Array的API

### 排序

笔试中：手写冒泡排序：从第一个元素开始，依次比较两个相邻的元素，如果前一个>后一个，两者就要交换位置

```
for(varj=1<arr.length;j++)i
	for(var i=O;i<arr.length-j;i++){
	if(arr[i]>arr[i+1]){	
	var m=arr[i];
	arr[i]=arr[i+1];
	arr[i+1]=m;
	}
}
```

数组提供了—个排序APl–正式开发:
语法: 

```
arr.sort();
```

特殊
1、默认转为字符串，按位pk每个字符的unicode(ASCII)

2、希望按照数字排序 - 升序

```
arr.sort(function(a,b){
	return a-b;
})
```

3、希望按照数字排序 - 降序

```
arr.sort(function(a,b){
	return b-a;
})
```

切记：以后网页看到任何带有排序功能的特效，说明它的底层一定是数组，因为JS中只有数组可以排序，先排序再数据渲染

## 栈和队列

添加元素和删除元素的新方式

栈:一端封闭，只能从另一端进出

队列:只能—端进入,另一端出

#### 栈

开头入

```
arr.unshift(新值,....)
```

开头出

```
var first = arr.shift();//一次只能删除一个，而且一定是删除的第一个元素，有可能删除的东西就是你需要的东西个人不喜欢:
```

开头进出，会导致每个元素的下标都会发生变化

尾入

```
arr.push();
```

尾出

```
var last=arr.pop()//一次只能删除一个，而且一定是删除的最后一个元素，有可能删除的东西就是你需要的东西至少不会影响到其他人的位置
```

## 拓展：周期性定时器

开启：

```
timer=setInterval(function(){
	操作
},间隔的毫秒数)
```

停止：

```
clearInterval(定时器名)
```

鼠标移入

```
elem.onmouseover=function(){
	clearInterval(定时器名)
}
```

鼠标移出

```
elem.onmouseout=function(){
	操作
}
```

## 二维数组

数组的元素，又一次引用了一个数组

### 何时使用

你希望再一个数组内再次细分分类如何使用:

```
var peoples=[
	["吴飞华".18,"洪兴"],
	["“冯伟朕",19,"东英"],
	["封永跃",20."三联"]
];
```

### 访问

```
arr[r][c]--r代表下标，c代表列下标
```

### 特殊

1、列下标越界，返回undefined

2、行下标越界，返回报错，因为行下标越界已经得到undefined再加[]则报错

### 如何遍历

```
固定公式:外层循环遍历行，内层循环遍历列
for(var r=0;r<peoples.length;r++){
	for(var c=0;c<peoples[r].length;c++){
  console.log(peoples[r][c])
}

```

### 总结：ES3提供的数组

1、数组的基础(创建、访问、添加、遍历、hash数组)
2、数组的API(10个: join、concat、slice、splice、reverse、sort、push、pop、shift、unshif)3、二维数组

## String的基础概念

什么是字符串：多个字符组成的【只读】字符【数组】

​	1、【只读】:字符串所有的API都不会修改原字符串，只会返回新的字符串

​	2、【数组】︰跟数组有相同点:
​	1、字符串可以使用下标获取某个字符	2、字符串可以使用length获取字符的长度

​	3、字符串可以遍历得到每个字符
​	4、字符串可以使用数组不修改原数组的APl(concat,slice)

差异:所有数组直接修改原数组的API，字符串都不可以使用! 字符串自己也有一堆API等待我们下周学习

## JS内置对象(引用类型):11个

​	String Number   Boolean

​	Array	Funtion	Date(日期)	Math(数学运算) RegExp(正则：验证) 

Error(错误) 

Object(面向对象)

Global(全局对象)：

1、保存着全局变量和全局函数，只不过浏览器端/客户端/前端global被window代替了，以后我们学习Node.js后端语言的时候你会发全局真的是global

2、唯独window对象可以省略不写

## String API

### 转义字符：/

#### 何时使用

在字符串中出现和程序冲突的字符

1、比如:希望在""中再放入一个"，或"之中再放入一个'

```
"\""
```

2、具有特殊功能

\n 换行   \t制表符：就是敲Tab带来的大空格

3、可以书写unicode号代表一个字

\uxxxx
汉字的第一个字: lu4e00

汉字的最后—个字: lu9fa5

#### 英文转大小写

【统—的】将字符串转为大写或小写，再比较，忽略大小写(验证码)

```
大写: var upper=str.toUpperCase();
小写: var lower=str.toLowerCase();
```

#### 获取字符串中某个字符

```
str.charAt(i);           ==         str[i];
```

#### 获取字符串中某个字符的ascii码

```
str.charCodeAt(i);
```

#### 通过ascii码转回原文:

```
原文=String.fromCharCode(ascii);
```

验证码

![2](D:\train\note\javascript\imgs\2.png)

#### 检索字符串

何时:判断有没有，不重复!

```
var i=str.indexOf("关键字" ,starti);
```

特殊

1、starti可以省略，如果省略默认从0位置开始向右查找

2、返回:如果找到了，返回关键字的第—个字符的下标

​	没找到返回-1，重点：我们其实根本不关心下标为几，我们只关心下标为不为-1，为-1说明没有，如果不为-1说明存在

3、数组也可以使用，其实以前数组是没有这个方法的，某次浏览器更新后，数组才可以使用的(老IE用不到)

4、【面试题】找到所有关键字的下标

```
var str="no zuo no die no can no bibi";
var index=-1;
while((index=str.indexOf("no",index+1))!=-1){
console.log("找到了，下标为: "+index);
)

```

#### 拼接字符串

```
var newStr=str.concat(str1 str2..)
```

#### 截取子字符串

```
1、var subStr=str.slice(starti,endi+1);
2、var subStr=str.substring(starti,endi+1);//几乎和slice一致，但是不如slice，因为不支持负数参数
3、 var subStr=str.substr(starti,n);
```

#### 替换字符串

```
var newStr=str.replace("固定关键字"/RegExp,"新内容");
```

#### 切割/分割字符串

功能：字符串< = > 数组

```
var arr=str.split("自定义切割符")
```

特殊

1、切割符是可以自定义的，切割后会返回一个数组，数组中不在包含切割符

2、如果传入的切割符""，每—个字符都会被切散

### 拓展：

#### input失去焦点事件

```
elem.onblur=function(){
}
```

#### JS创建页面元素并且渲染上DOM树

1、创建空标签

```
var xin元素=document.createElement("标签名");
```

2、为此标签设置必要的属性和事件

```
空标签.属性名="属性值"
```

3、把新元素上DOM树

```
父元素.appendChild(新元素)
```

## 正则表达式

什么是:定义字符串中【字符出现规则】的表达式

### 何时使用

切割替换“验证”

### 如何使用

#### 最简单的正则

关健字原文，但是写法和以前的字符串不同,“no” ->  /no/ig

```
i:忽略大小写
g:全部，替换的话默认只会替换第一个匹配到的关键字
```

#### 备选字符集

—个备选字符集:规定一位字符可能出现的情况

何时使用：只要关键字有多种情况的时候

如何使用：/{备选字符集}/

强调：1、一个中括号，只能管一个字

​			2、问题：正则默认只要满足后，就不再管后续操作，后续用户就可以乱来!

​				解决：【只要是做验证】，我们肯定希望用户完全按照我们的规则来玩，必须写为:/^[备选字符集]$/·前加^后加$的意思是要求用户从头到尾完全匹配

特殊：

```
1、如果备选字符集种有部分unicode号是连续的，则可用-省略掉中间部分
比如：
	—位数字:[0-9]
	—位字母:[A-Za-z]
	—位数字、字母、下划线:[O-9A-Za-z ]
	—位汉字:[\u4e0O-\u9fa5];
2、除了xxx之外，其他都可以
	[^xxx]–范围太广，不推荐
```

#### 预定义字符集

前辈们提前定义了的一些常用的字符集

```
一个数字: \d   ===   [0-9]
位数字、字母、下划线: \w  ===
[0-9A-Za-z_]
一位空白字符:\s   ===
空格、制表符、换行
—位除了换行外的任意字符:. -范围太广，不推荐
```

问题:预定义字符集是固定的，不灵活

建议:开发时优先使用预定义字符集，预定义字符集满足不了，再用备选字符集补充

##### 强调：不管是备选字符集还是预定义字符集，一个都只管一位

#### 量词

规定了—个字符集出现的次数

##### 如何使用

1、有明确数量：

```
字符集{n,m}:前边相邻的字符集最少出现n次，最多出现m次
字符集{n,}:前边相邻的字符集最少出现n次，多了不限
字符集{n}:前边相邻的字符集必须出现n次
```

2、没有明确数量

```
字符集?:前边相邻的字符集，可有可无，最多一次
字符集*:前边相邻的字符集，可有可无，多了不限字符集
字符集+:前边相邻的字符集，至少—次，多了不限
```

#### 指定匹配位置

```
^:以xxxxx开头
$:以xxxxx结尾
*特殊:如果同时使用了，前加^后加$，从头到尾完全匹配-只要是做验证，必须这么写
```

#### 选择和分组

选择：可以再多个条件中选择一个

```
规则1|规则2
```

分组：选择和分组—般来说都是需要搭配使用的 - 添加子规则

```
(规则1|规则2)
```

7、目的:密码强度:4-6位密码，可以输入字母数字，但是必须要有一位大写和一位数字的组合

公式：比如

```
    1、/^(?![0-9]+$)$/ -不能全由数字组成，可能有大写字母、小写字母、汉字、特殊符号、日文、韩文...
2、/^(?![A-Zd-z]+$)$/–不能全由大写组成，也不能全由小写组成，也不能由大写和小写的组合组成，可能有数字
```



## 字符串支持正则的API

### 切割

```
str.split("固定切割符/正则表达式")
```

### 替换

#### 基础替换法

```
str=str.replace(/正则表达式/gi,"新内容");
注意：替换时，不要前加^后加$，我们不需要完全匹配，只需要找到关键字做替换而已，想要替换所有的一定要加后缀g
```

问题：替换的新东西，只能是一个固定的

#### 高级替换法

```
str=str.replace(/[我卧握窝][去槽操曹草]+/g,function(key,i,str)//此回调函数会自动调用，找到几个关键字就会执行几次
console.log(key);//当前次正则匹配到的关键字
console.log(i)://当前次正则匹配到的关键字的下标console.log(str);//原文本身
return key.length==2?"**"."***":
});
```

#### 格式化

如果替换时，正则中，带有分组，那么你的回调函数会得到更多的形参

```
var str="500103198602215933";
var reg=/d{6](d{4})(Nd{2))(d{2)d{4}/;
str=str.replace(reg,function(key,a,b,c,....,i,str){
console.log(key);//正则匹配到的内容
console.log(a);//第一个分组匹配到的内容
console.log(b);//第二个分组匹配到的内容
console.log(c)://第三个分组匹配到的内容/ /...
你有多少个分组就会多出多少个形参，但是最后两个—定是下标和原文
console.log(i);
console.log(str);
return a+"年"+b+"月"+c+"日";
console.log(str);

```

## 正则对象

### 创建：

1、直接量方式：

```
var reg=/正则表达式/后缀;
```

2、构造函数方式: var reg=new RegExp("正则表达式"，"后缀");

### 方法：

```
var bool = reg.test(user)
根据布尔值去做出正确的提示文字和样式，以及错误的提示文字和样式
```

## Math

专门用于提供数学计算的API

强调：不能、不需要创建，浏览器自带

属性：Math.API

### API

#### 取整：3种

```
上取整:只要超过，就会取下一个整数
	Math.ceil(num); -小数位数不能超过15位，超过后会失效

卜取整:无论超过多少，都省略小数部分
	Math.floor(num);

四舍五入取整
	Math.round(num)
```

以上三个都是垃圾:只能取整,而且不能指定保留小数位数：个人推荐num.toFixed(d)；//d可以设置指定保留小数位数，而且也具有四舍五入的功能，唯一缺陷：返回的是个字符串。建议搭配parseInt()使用

【面试题】：自定义一个函数，按照人员小数位数四舍五入，返回数字类型，不允许使用tofixed

```
function dy(num,d){
	num*=Math.pow(10,d);
	num=Math.round(num);
	num/=Math.pow(10,d);
	return num;
}
var result=dy(Math.PI,3);
console.log(result)
```



#### 乘方和开方

```
乘方：Math.pow(底数,幂)；
开放：Math.sqrt(num)   -只能开2次方
```

#### 最大值或最小值

var max/min=Math.max/min(num1,num2,....)

可以获取出传入的参数中最大/小的值

问题:不支持传入数组参数，比较数组的最大值和最小值解决: Math.max/min.apply(Math,arr);
其实apply可以悄悄的打散数组，将每个元素单独传入-ES5带来的一个新特性其实apply可以借用方法
笔试题:比较出数组中最人值/最小值（2个方法)

#### 绝对值

将负数变成正数

```
Math.abs(num);
```

#### 随机数

```
Math.rondom():在0-1之间取随机数
		可能取到0，但是不可能取到1  -可能取到最小数,但是不可能取到最大数
在min~max之间取随机整数的公式
parseInt(Math.random()*(max-min+1)+min;)
如果你的最小值是0
parselnt(Math.random()*(max+1));
```

## Date

封装了一个事件对象，提供了对时间进行操作的API的对象

### 何时使用

只要计算时间，就要用到Date

### 如何使用

#### 1、创建

##### 1、创建一个日期对象，获取客户端当前时间

```
var now =new Date();
```

##### 2、创建一个自定义时间

```
var birth = new Date("yyyy/MM/dd hh:mm:ss")
```

##### 3、创建一个自定义时间(另一种):

```
var birth=new Date(yyyy,MM-1,dd,hh,mm,ss);
```

取值范围: MM: 0~11月份需要修正

##### 4、复制—个日期对象

为什么:日期对象的API都是直接修改原日期对象的，无法获得修改之前的日期
何时使用:如果你希望同事获得修改前和修改后的两个日期，则应该先复制一份，然后再去修改其中一份

```
var end =new Date(start);
```

### 2、使用

1、拿着两个日期对象可以相减，你会得到一个毫秒差，通过毫秒差换算你想要的任何一部分

#### API操作

2、API操作：分量：时间单位

```
年月日星期:FullYear Month Date Day
时分秒毫秒: Hours Minutes Seconds Milliseconds
```

##### 1、每个分量都有一对getXX /setXX

特殊：Day：没有set方法

2、取值范围：

```
FullYear:就是当前年份的数字
Month: 0~11，计算机中的月份比现实-1
Date: 1~31
Day: 0~6:0代表星期天，外国人的眼里，星期天是一个星期的第一天
Hours:0~23
Minutes、Seconds: 0~59
```

3、日期看上去像一个字符串—样黑色的，但是日期对象和字符串能用的API不同，而且日期对象很聪明，会自动进制

建议：对一个日期的某个分量做计算

```
date.setXXX(date.getXXX()-/+n)
```

### 3、日期格式化

```
date.toLocaleString();
/会转为一个本地日期格式的字符串，虽然不能自动进制，也不能用日期的API，但是可以用字符串的API了
```

垃圾:具有兼容性问题，老E输出的和主流浏览器输出的东西不—样

解决:自定义format函数

## Error对象:错误对象

### 1、浏览器自带4种错误类型–帮助你们快速找到错误

```
SyntaxError -语法错误:一定是符号/语法写错
ReferenceError -引用错误:没有创建的东西，你就去使用了
TypeError -类型错误:使用了不是自己的属性和方法
RangeError -范围错误:只有一个API会遇到,num.toFixed(d):
//d必须在0~100之间
```

### 2、错误处理:当程序发生错误时，保证程序不会异常中断的机制

为什么:程序默认只要碰到错误就会停止/闪退，用户体验感差如何错误处理:
try{
可能发生错误的代码
}catch(err){
发生错误时才会执行，err形参会自动得到错误的信息，英文的建议你自己在加上中文错误描述
)
性能垃圾:放在try中的代码，效率都会被降到最低
解决:完全可以用if...else代替 try...catch，所有的一场都可以提前预判
需要经验的累积:一切客户端都是坏人，都要防他一手:

1、if...else.. 2、!isNaN 3、【正则验证】

### 3、抛出自定义错误/异常:

throw new Error("自定义文字");

## Function对象:【考点】

提前创建好，以后可以反复使用的代码段

js中的函数也是一个对象，函数名其实是引用函数对象的变量

### 创建：3种

#### 声明方式：

```
function函数名(形参列表)(函数体;return返回值;} -完整的声明提前
```

#### 直接量方式：

```
var函数名=function(形参列表){函数体;return返回值;} –完整的声明提前
	拓展：
		d1.onclick=function(){}
```

#### 构造函数方式：

```
var函数名=new Function("形参",...,"函数体;return 返回值;");
	
强调:无论参数实际是什么类型，创建函数时的每一部分都必须用""包裹
```

##### 何时使用

如果函数体不是固定的，而是字符串动态拼接的

### 作用域

### 声明提前

### 按值传递

### 重载(overload)

相同函数名，不同参数列表的多个函数

为什么：减轻程序员的负担！

#### 问题

JS的语法不支持重载!JS不允许同时存在多个同名函数，如果同时存在，最后一个的函数会覆盖掉之前所有的

#### 解决

在函数内部有—个对象: arguments

什么是arguments对象:函数中，自带的，不需要我们创建的，是一个类数组对象，作用:接受住所有的实参

##### 类数组对象

只有3个点是和数组相同

```
1、都可以用下标访问某个元索
arguments[i]-传入的某个实参
2、都可以用length获取到长度
arguments.length
3、可以遍历拿到每一个元素– for循环
强调:类数组对象不是数组，所有的数组的APl，类数组都不能使用
```

###### 何时使用：

```
1、以后不需要形参，也可以接住所有的实参!
2、变相实现重载:在函数内部判断传入的实参的不同，执行不同的分支操作
```

### 匿名函数

创建的函数，没有函数名引用着

#### 何时使用：

如果函数，只会执行一次

为什么:节约内存，匿名函数没有变量引用着，用完，就会自动释放

##### 匿名函数自调

只会执行一次，执行完毕后会自动释放，代替全局写法，节约内存空间

```
(function(){
	console.log("我是匿名自调");
})();
```

##### 匿名函数回调

将函数调用时，传入的实参，又是一个匿名函数，不需要我们程序员调用，会由主函数自动执行

确实是前辈们，怎么规定，我们怎么使用，但是我们了解到，原来这个回调函数不是没有调用，只不过是前辈们提前帮我们调用好了

```
function A(B){
	B();
	console.log("我是主函数" );
}
A(function(){
	console.log("我是副函数");
})
```

```
arr.sort(function(a,b){return a-b;})
str.replace(reg,function(){})
btn.onclick=function(){} -就算你听懂了怎么简化为箭头函数，也暂时不要在事件上写箭头函数
```

## 闭包

### 作用域(scope)

#### 全局作用域

成员:随处可用，可以反复使用，缺陷:容易被污染

#### 函数作用域

成员:不会被污染，只有函数调用时内部可用，缺点:调用结束后，就释放了，一次性的，不可反复使用

### 函数的执行原理

#### 1、程序加载时

​	创建执行环境栈(ECS):保存函数调用顺序的数组

​	首先压入全局执行环境(全局EC),全局EC中引用着全局对象window，window中保存着全局变量

#### 2、定义时

创建函数对象:封装代码段

在函数对象中定义了scope属性，记录着函数来自的作用域，全局函数的scope都是window

#### 3、调用前

在执行环境栈中压入新的函数的EC
创建出活动对象(AO):保存本次函数调用用到的局部变量在EC中添加了scope chain(作用域链)属性引用着AO设置AO的parent属性为函数的scope引用的对象

#### 4、调用时

变量的使用规则:优先使用局部变量，局部没有找全局，全局没有就报错

#### 5、调用完

函数的EC会出栈，AO自动释放，局部变量也就自动释放

### 两链一包

#### 作用域链(scope chain):

以函数的EC中的scope chain属性为起点，经过AO，逐级引用，形成的一条链式结构

##### 作用：

查找，带来了变量的使用规则:优先使用局部变量，局部没有找全局，全局没有就报错

### 闭包：

保护—个可以【反复使用的局部变量】的一种词法结构

#### 为什么

全局变量: 缺:容易被污染

局部变量: 缺:—次性

#### 如何使用

1、两个函数进行嵌套
2、外层函数创建受保护的局部变量，并且返回内层函数

3、内层函数在操作受保护的局部变量

简单的例子

```
function outer(){
	var i=0;
	return function(){
		i++;
		return i;
	}
}
```

#### 强调

1、判断闭包，有没有两个函数在嵌套，并且外层函数创建了变量,return了内层函数

2、外层函数调用几次，就创建了几个闭包，受保护的变量就有了几个副本

3、同一次外层函数调用，返回的内层函数，都是使用同一个受保护的变量

缺点：唯一的缺点：受保护的变量永远不会被释放，过度使用闭包，会导致内存泄漏

#### 使用场景：

防抖节流 -3个事件会非常影响性能

##### 防抖节流公式：

```
function fdjl(){
	var timer;//受保护的变量
	return function({
	/操作受保护的变量
	if(timer){clearTimeout(timer)}
		timer=setTimeout(function(){
		//考虑你要做的操作是什么
		},1000)
	}
}
var inner=fdjl();
//inner()内层函数才是写在事件中的操作
```

​	

```
1、elem.onmousemove-鼠标移动就会触发，触发次数很多很快，但是不要让他疯狂的渲染DOM

2、window.onresize
-窗口的尺寸只要发生变化就会触发，

```

## Object

面向对象开发方式:

三大特点:封装、继承、多态

### 【面试题】:简单的说一下你了解的面向过程和面向对象开发方式的区别?

面向过程:开始->经过->结束，我们从开始到现在学习写法的一直都是面向过程
面向对象:对象（属性和方法)，如果这个世界有各种属性和各种方法，但是连一个对象/生物都没有，那这些东西就没有具体的意义,我们把所有的代码全部包含在一个对象中来进行描写，才更符合现实生活

之前用的11个引用类型对象，都是浏览器的js解释器提供的，我们直接学习如何使用，但是我们现在可以学习如果创建属于自己的对象(可惜前辈们没有提供过轮播、选项卡、购物车)

### 学习如何创建自定义对象:

#### 1、封装/定义/创建对象:3种

#### 1、直接量方式:

```
var obj={
	"属性名":属性值,
	"方法名":function(形参){函数体},
	…
);

强调:
1、属性名和方法名的引号其实是可以省略的，但是不建议，因为以后我们会学习一种数据格式叫做JSON.要求属性名和方法名的【双引号】不能省略
2、如何访问对象的属性和方法
		对象名.属性名			===		对象名["属性名"] 
		对象名.方法名();		===		对象名["方法名"]()
js中万物皆对象，除了undefined和null，一切对象的底层都是哈希数组

特殊：1、访问到不存在的属性，返回undefined
	 2、随时随地可以添加不存在的属性和方法
	 3、希望获取到对象之中所有的东西：遍历对象：for in循环
	 	for(var i in obj){
			console.log(obj[i]);
		}
	 4、如果你希望在对象的方法内部使用对象自己的属性，我们需要写为this.属性名;
		this指向
		1、单个元素绑定事件this->这个元素
		2、多个元素绑定事件this->当前元素
		3、函数中this->谁在调用此函数this指向谁
		4、定时器中this->window  
		5、箭头函数this->外部对象
```

### 2、构造函数方式：垃圾

```
var obj=new object(); 
obj.属性名=属性值;
obj.方法名=function()
//obj.name="袍哥";
//obj.age=18;
//obj.salary=200000;
```

以上两种创建方式有一个缺点：仅仅适合创建单个对象，如果创建多个对象，代码冗余太高

### 3、专门创建多个对象准备的

#### 自定义构造函数方式：2步

```
1、创建构造函数
function类名(name,age,hobby){
	this.name=name;
	this.age=age;
	this.salary=salary;
}
2、调用自定义构造函数创建出对象
var obj=new类名(实参…);
```

面向对象开发方式的好处: 

​	1、不适合初学者，逼格高！

​	2、特地把每一块功能分开写 - 哪怕不需要注释，也便于维护！

​	3、铁索连舟 -更符合现实生活

​	4、所有东西都包含在一个对象之中- 更符合现实生活

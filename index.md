## 概述

JavaScript：简称JS,是一个运行在客户端浏览器的【解释型】【弱类型】【面向对象】脚本语言

1.	编译型：在运行程序之前，需要先检查语法是否正确，如果不正确，直接不允许运行- 严格,不如：java/c++/c#...

​	    解释型：在运行程序之前，不需要先检查语法是否正确，直接运行，但是遇到错误后停止运行后续代码

2. 弱类型：变量保存的数据是可以随意的，数据类型是由数据来决定的 -更加的自由

​       强类型：变量保存的数据，是由数据类型来决定的  -Java -更加的严格

3.特点：

​			2.解释型

​			3.弱类型

​			4.面向对象编程方式

​			5.可以做一切css完成不了的效果

## 组成

JavaScript其实由三部分组成

ECMAScript - 核心语法

DOM - Document  Object Model -文档对象模型，可以用js 来操作HTML和CSS

BOM - Browser Object Model - 浏览器对象模型，可以操作浏览器

## 如何使用JS

### 使用方式

​	1.使用方式：2种

​				1.直接在html页面上写一个script标签，里面就可以书写js代码

```
<script></script>
```

​				2.外部JS,进行引入 - 正式开发时使用

```
1)创建xx.js，里面书写js代码
2)在html页面引入
	<script src="js文件路径">
		只要有了src属性，此处就不可以在写代码了
	</script>
```

### 输出方式	

2.输出方式：帮助我们检查错误：3种

​			1、在控制台输出日志：

```
console.log(想要输出/查看的东西)
```

​			2、在页面上输出日志：

-缺点:如果绑定了点击事件，则之前的html+css消失了

-在页面上输出，而且支持识别标签

```
document.write(想要输出/查看的东西)
```

​			3、在弹出框输出日志：

-在浏览器自带的弹出框输出日志，但是弹出框会卡住页面，用户看到的只是白板

```
alert(想要输出/查看的东西)
```

### *变量和常量

​	*变量：创建后，值可以再次修改

​	何时使用：以后反复使用到的数据，都要提前把他保存在一个变量中，以后使用变量名，相当于就是在使用变量的值

​	如果使用：

```
var 变量名 = 值;
```

​	特殊：

​		1.变量名其实不是随意的

```
1.变量名其实不是随意的
2.不能以关键字命名
3.建议下划线命名法 或 小驼峰命名法
```

​		2.如果你的变量名是name，不管你保存的数据是什么数据类型，都会悄悄转换成字符串

​		3.多个变量创建可以简写：
​				var 变量名=值1，变量名=值2...;

​	常量：创建后，值不可以再次修改，只能设置一次值	

```
const 常量名 = 值;
```

### *算术运算符：+ - * / % 

​	1.%：读作取余，俗称模，两个数相除，不去商，而取除不尽的余数

​			固定套路：

​			1、判断奇偶性

​			2.获取一个数字的倒数n位

​	2.***特殊：其实算数运算符具有隐式类型转换，默认转为数字在运算

​			+运算：如果左右两边单反出现一个字符串，那么悄悄的转为字符串，+运算不再是+运算，而是拼接

​			- * / %：字符串也可以变为数字，但必须是纯数字组成的字符串 如果字符串包含了非数字字符，直接转为NaN: Not A Number (不是一个数但是是数字类型)



### *数据类型

原始/基本/值类型：5个

​		1、Number - 数字，取值：无数个

​		2、String - 字符串，取值：无数个，必须写上"" 或''

​		3、Boolean - 布尔 ，取值：两个：true/false -往往用于判断比较的条件处使用

​		4、Undefined - 取值：一个：undefined，创建了一个变量，但是没有赋值，默认值为undefined(祖师爷犯的错，用来做大部分操作都会报错！)

​		5、Null - 空 取值：1个：null，释放变量/内存，节约内存空间

引用/对象类型：11个引用类型的对象(很多很多的属性和方法)

### 分支结构

判断条件的不同选择对应的代码去执行，执行力一条路就不会再走别的路

#### 如何使用

​		一个条件，一件事，满足就做，不满足就不做

```
		if(判断条件){
			操作；
		}
```

​		一个条件，一件事，满足就做，不满足就做第二件

```
		if(判断条件){
        操作1；
		}else{
			操作2；
		}
```

​		多个条件，多件事，满足谁就做谁

```
		if(判断条件){
			操作1；
		}else if{
			操作2；
		}else{
			操作3；
		}
```

特殊：

​	1、else if...你想写多少个随便，根据你的需求自己判断

​	2、最后的else可以省略不写，如果条件都不满足，那么什么事都不会执行，分支白写

​	3、书写判断顺序，需要根据你的需求来写，不能乱写顺序

### 用户输入弹出框

```
var 变量名 = prompt("提示文字","默认值")
```

## 数据类型转换

不同的数据类型做操作可能出来的结果是不一样的

​	Number + Number = Number

​	Number + String = String

js获取页面上的一切东西，数据类型默认都是一个字符串

如果你想要查看数据类型：

```
typeof(想要查看的东西);
```

### 算数运算符的隐式转换

默认：算数运算符具有隐式类型转换，默认转为数字在运算

特殊：

​	1、+运算：如果左右两边单反出现一个字符串，那么悄悄的转为字符串，+运算不再是+运算，而是拼接

​	2、别的数据类型其实也可以转为数字

​			true->1   false->0    null->0     undefined->NaN

​	3、其实- * / %，字符串也可以转为一个数字，前提是一个纯数字组成的字符串

​	4、NaN: Not A Number：不是一个数字，但是确实是数据类型，不是一个有效数字

​			NaN的特点：

​			1.参与任何运算都是NaN

​			2.参与任何比较都是false

#### 如果判断NaN

​	问题：我们没有办法使用普通的比较方法判断数据是不是NaN

​	解决：

```
isNaN(x)
	true->是一个有效数字
	false->是一个无效数字
```

### 显示/强制转换

隐式转换出来的结果不是我们想要的，我们程序员就要手动调用一些方法，强制转为我们需要的类型，再做操作

#### 转字符串

```
var str=x.toString();//x不能是undefined或null，因为undefined和null不能使用任何的操作页面上的一切东西，数据类型默认都是一个字符串
```

#### 转数字

```
方法一:parseInt(str/num);  parse->解析 Int->整型
```

执行原理:专门为字符串和小数转为整数数字准备的，从左向右依次读取每个字符，碰到非数字字符，就停止转换，如果一来就碰到不认识的，则为NaN

```
方法二:parseFloat(str);  parse->解析 float->浮点型
```

执行原理:几乎和parseInt一致，认识第一个小数点

```
方法三:Number(x) 
```

此方法是万能的，任何人都可以转为数字。。完全等效于隐式转换

## Function基础

函数，陈志文方法:需要提前【预定义】好，以后可以【反复使用】的【代码段】

### 如何使用

#### 1.定义/声明/创建函数

```
function 函数名(){	
	代码块
}
```

#### 2.调用/使用函数

```
1.要么在js中程序员直接写死，要执行几次:函数名()
2.交给用户绑定在某个元素上，写上点击事件，让用户来触发:
	<elem onclick="js代码">内容</elem>
```

#### 3.何时使用

1.不希望打开页面立刻执行，而需要是再使用 或 由用户来触发
2.希望能够反复执行，不用刷新页面

3.以后任何一个独立的功能体，都要单独封装为一个函数

4.封装函数yyds

5.函数内的一切内存，函数调用完毕后都会自动释放

#### 4.带参数的函数

函数   参数

创建：形参：形式参数，其实就是一个变量，但是不需要写var，而且默认也没有保存任何值，默认值为undefined

```
function 函数名(形参,形参...){	
	函数体
}
```

使用：实参：实际参数，真正的值，需要再调用时再传入

```
函数名(实参,实参...)
```

特殊:1、传实参的顺序一定要和形参的顺序一一对应，并且数量也要对应
2、不是一定要带参数的函数才是好函数，具体情况，需要具体分析:
	如果你的函数体就是固定的-则普通函数
	如果你的函数体希望根据传入的实参不同，做的略微不同–则带有参数的函数

### 分支结构

#### 程序的流程控制语句:3种

1.顺序执行 - 默认,从上向下的依次执行

2.分支结构 - 通过条件的判断，选择部分代码执行

3.循环结构 - 通过条件的判断，选择要不要重复执行某些代码

#### 比较运算符

<  >   <=  >=  ==   !=

用于做判断/比较的

结果:一定是个布尔值

强调：如果你想要判断多个条件，绝对不能像小时候数学的写法：区间写法

#### 逻辑运算符

&&：与    -要求全部条件满足最后结果才为true，否则为false

||：或 	-要求全部条件不满足最后结果才为false，否则为true

！：颠倒布尔值

## 循环结构

反复执行【相同 或 相似】的操作

​	循环三要素：

​		1.循环条件：开始 - 结束，循环的次数

​		2.循环体：做的操作是什么

​		3.循环变量：记录着我们当前在哪一次，而且他会不断的变化，往往都会向着不满足循环条件进行

### while循环

```
var 循环变量=
while(循环条件){
	循环体;
	循环变量变化
}
```

执行原理：首先创建了循环变量，然后判断条件，如果条件满足，则做【一次】循环体操作，并不会退出循环，回头继续判断条件满足吗，如果满足，则再做【一次】直到循环条件不满足，再退出循环

宏观上感受循环一瞬间就结束了，但是微观上其实是【一次一次】执行的

特殊：

1、有的时候真可能不知道从何开始，到何处结束，死循环：永远不会停下

```
while(true){
	循环体;
}
```

2、退出循环语句：break - 只能在循环中使用，多半都是搭配死循环使用的

随机数公式：

```
parseInt(Math.random()*(max-min+1)+min)
```

### for循环

```
for(var 循环变量=x; 循环条件;变量的变化){
	循环体
}
```

同时支持死循环

```
for(;;){
}
```

面试题：while 和 for 的区别？

​		语法上有区别，但两者都能做到相同的操作

​		一般来说我们不确定循环次数的时候，会使用while死循环

​		一般来说我们确定循环次数的时候，会使用for循环

## 数组基础

变量其实就是我们的内存， 变量创建的越多，我们内存空间消耗越大，那么网站的性能就越差

数组：创建一个变量可以保存【多个数据】的集合

​	数组都是线性排列，除了第一个元素，每个元素都有唯一的前驱元素

​	除了最后一个元素，每个元素都有唯一的后继元素

每个元素都有自己的位置。称之为下标，下标从0开始，到最大长度-1

### 创建数组：2种

1、直接量数组

```
var arr=[];//空数组  其实[]的方式是ES3才带来的，原来只有用new Array才能创建数组
var arr=[数据1，数据2...];
```

2、构造函数方式

```
var arr=new Array();
```

### 获取数组的数据

```
数组名[下标];
```

### 添加/替换

```
数组名[下标]=新值;
下标处有没有元素，如果没有则为添加，如果有了就替换
```

### 数组三大不限制

1、不限制元素个数

2、不限制元素类型

3、不限制元素的下标越界

​		如果获取元素，下标越界，返回的一个undefined

​		如果添加元素，下标越界，会得到一个稀疏数组，导致下标不再连续，如果搭配上循环去遍历每一个元素的话，我们会得到很多很多的undefined



解决：数组中唯一的属性：长度-获取当前数组的长度：最大下标+1

```
数组名.length
```

固定方法：

1、获取倒数第n个元素：

```
arr[arr.length-n];
```

2、始终向末尾添加元素：

```
arr[arr.length]=新值;
```

3、缩容：删除倒数n个元素

```
arr.length-=n;
```

往往很多情况，我们不会拿出某个元素来使用，而是拿出所有的每个元素来进行相同或相似的操作

### 遍历数组

```
for(var i=0;i<数组名.length;i++){
	console.log(数组名.[i])
}
```

## DOM

文档对象模型：专门用于操作HTML文档的，提供一些属性和方法等待我们学习

### DOM树概念

DOM将我们的HTML看作是一个倒挂的树状结构，但是树根不是html标签，而是document对象

document对象是由浏览器js解释器自动生成的，一个网页只有一个document

作用：可以通过树根找到我们想要的任何一个DOM元素/节点/对象(属性和方法)

DOM会将页面上的每一个元素、属性、文本、注释都会当作一个DOM元素/节点/对象

### 查找元素

#### 通过ID查找元素

```
var elem=document.getElementById("id值")
特殊：
	1、返回值，找到了返回的是一个找到的DOM元素，没找到返回值是null
	2、找到多个相同的id，也只会返回第一个
	3、垃圾方法，一次只能操作一个
	4、其实根本不需要使用此方法，直接写ID也可以找到元素 - 偷懒的写法
```

#### 通过标签名查找元素

```
var elem=document/已经找到的父元素.getElementByTagName("标签名")
特殊：
	1、返回值：找到了返回的是一个类数组DOM集合(很想数组，都能用下标，都能用length，都能遍历)，没找到返回一个空集合
	2、*js不能直接操作DOM元素集合，只能直接操作DOM元素
		解决：要么使用下标拿到某一个元素，要么使用遍历拿到每一个元素
	3、不一定非要从document开始查找，如果document去找，会找到所有元素，可以换成我们已经找到的某个父元素，就只会找到这个父元素下面的元素
```



#### 通过class名查找元素

```
var elem=document/已经找到的父元素.getElementByClassName("标签名")
特殊：
	1、返回值：找到了返回的是一个类数组DOM集合(很想数组，都能用下标，都能用length，都能遍历)，没找到返回一个空集合
	2、*js不能直接操作DOM元素集合，只能直接操作DOM元素
		解决：要么使用下标拿到某一个元素，要么使用遍历拿到每一个元素
	3、不一定非要从document开始查找，如果document去找，会找到所有元素，可以换成我们已经找到的某个父元素，就只会找到这个父元素下面的元素
```

#### 通过关系查找元素

前提条件：必须先找到一个元素才可以调用关系网

```
父元素：elem.parentNode
子元素：elem.children
第一个儿子：elem.firstElementChild
最后一个儿子：elem.lastElementChild
前一个兄弟：elem.previousElementSibling
后一个兄弟：elem.nextElementSibling
```

### 操作元素

前提：找到元素才能操作元素：

```
<标签 属性名="属性名" style="样式">内容</标签>
```

#### 1、内容

​	1、innerHTML: 获取 和 设置 开始标签到结束标签之间的内容 - 支持识别标签

```
	获取: elem.innerHTML;
	设置:elem.innerHTML="新内容";
```

​	2、innerText: 获取 和 设置 开始标签到结束标签之间的文本 -不支持识别标签

```
	获取: elem.innerText;
	设置:elem.innerText="新内容";
```

​	以上两个属性都是为双标签准备的，但是操作不了单标签input的内容

​	3、value:专门为input的value值准备的

```
	获取: input.value;
	设置:input.value="新内容";
```

#### 2、属性

```
	获取属性值:elem.getArrtibute("属性名");
	设置属性值:elem.getArrtibute("属性名","属性值");
	
	简化版：
	获取属性值:elem.("属性名");
	设置属性值:elem.属性名="新属性值";
			缺陷：
				1.class必须写为className -2015年过后，ES6诞生过后，class变成一个关键字
				2.不能操作自定义属性，只能操作标准属性
```

#### 3、样式

```
	获取/设置属性值:elem.style.css属性名="css属性值";
	特殊：
		1、css属性名，有横线的地方，去掉横线，变为小驼峰命名法
			border-radius -> borderRadius
		2、目前学习的，获取时，只能获取内联样式
```

#### 4.绑定事件

```
	elem.on事件名=function(){
			操作;
			this关键字：目前只能用于事件内;
					如果单个元素绑定事件:this->这个元素
					如果多个元素绑定事件:this->当前
	}
```

总结：

​	获取 --往往都是用于判断，比较

​	设置 --就是修改/添加


计算字符串：脱掉字符串的外套

```
eval("")
```

eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。

如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。

![](https://1217944250.github.io/veicos.github.io/imgs/1.png)
## 数据类型转换

### 强制转换

#### 转字符

```
var str=x.toString();
```

#### 转数字

```
方法一:parseInt(str/num);  parse->解析 Int->整型
```

执行原理:专门为字符串和小数转为整数数字准备的，从左向右依次读取每个字符，碰到非数字字符，就停止转换，如果一来就碰到不认识的，则为NaN

```
方法二:parseFloat(str);  parse->解析 float->浮点型
```

执行原理:几乎和parseInt一致，认识第一个小数点

```
方法三:Number(x) 
```

此方法是万能的，任何人都可以转为数字。。完全等效于隐式转换

#### 转布尔

```
Boolean();
只有六个会为false
Boolean(0);
Boolean("");
Boolean(undefined);
Boolean(null);
Boolean(NaN);
Boolean(flase);
```

## 运算符和表达式

### 算数运算符

 + - * /  %



### 比较运算符

<  >   <=  >=  ==   !=  ===   !===

用于做判断/比较的

结果:一定是个布尔值

隐式转换：转成数字再比较

特殊：

​	1.如果参与比较的左右两边都是字符串，则按位pk每个字符的十六进制的unicode号(十进制ASCII码)

​	ACSII码顺序	0-9<A-Z<a-z<汉字

​	2.NaN参与任何比较运算结果都为false，所以没有办法使用普通的比较运算来判断x是不是NaN

```
!isNaN(x);
```

​	3.undefined==null;//true

区分：undefined===null;

全等：=== -要求数值相同，并且数据类型也要相同，不再带有隐式转换

!== - 不再带有隐式转换的不等比较

### 逻辑运算符

作用：综合比较，结果也是布尔值

隐式转换：左右两边都会悄悄转为布尔值，再综合比较结果

&&：与    -要求全部条件满足最后结果才为true，否则为false

||：或 	-要求全部条件不满足最后结果才为false，否则为true

！：颠倒布尔值

特殊：短路逻辑：如果前一个条件，已经可以得出最终结果了，没有必要看后续

#### &&短路

​	&&短路：如果前一个条件满足，才执行后一个条件，如果前一个条件不满足，则不管后续条件

​		目的：简化简单的分支：1、一个条件一件事，满足就做，不满足就不做	2、操作只能有一句话：多句操作导致我们以后维护目的观看

​		语法：

```
条件&&(操作);
```

#### ||短路

实现浏览器兼容性问题：二选一

​	e=e || window.event；

### 位运算

左移：m<<n,读作m左移了n位

左移：m>>n,读作m右移了n位

### 赋值运算

+= -= *= /= %= ++ --

​	一句话完成两个操作，先计算，在赋值回去

##### 【面试题】

i++ 和++i的区别

单独使用时，放前放后无所谓效果一样
但是如果参与了别的表达式，变量中的值都会＋1
前++【返回的是加了过后】的新值

后++【返回的是加了过前】的旧值

### 三目运算

简化if...else...     if...else if...else

三目运算符：又称之为三元[运算符](https://so.csdn.net/so/search?q=运算符&spm=1001.2101.3001.7020)

格式：

```
(关系表达式)?表达式1:默认操作;
(关系表达式1)?表达式1:(关系表达式2)?表达式2:默认操作;
```

如果关系表达式的结果为true，运算后的结果是表达式1；

如果关系表达式的结果为false，运算后的结果是表达式2；

### 拓展

1、四舍五入

解决：num.toFixed(d)d代表保留小数位，会四舍五入

缺陷：返回的是要字符串，建议搭配parseFloat食用

2、

### 获取字符串中第一个字符的ASCII码

```
elem.charCodeAt(0);
```



## 函数

也叫做方法，是需要预定义好的，以后可以反复使用的代码段

### 创建函数并且调用

#### 声明方式创建函数

用一个关键字function做声明

```
	function 函数名(形参列表){
		函数体;
		return 返回值;
	}
```

调用函数：函数名(实参列表)

#### 直接量方式创建函数

函数名其实就是一个变量名

	var 函数名=function(形参列表){
		函数体;
		return 返回值;
	}

### 作用域

#### 全局作用域

全局变量和全局函数，在任何地方都可以使用

#### 函数/局部作用域

局部变量和局部函数，在【函数调用】时内部可用

<font color="red">带来了变量的使用规则:优先使用局部的，局部没有找全局，全局没有就报错</font>

#### 声明提前(笔试重点)

真正开发不会用

原理：

在程序正式执行之前，

会将var声明的变量和function声明的函数，

集中提前到当前作用域的顶部，

变量比函数轻，但是赋值留在原地



### 按值传递

两个变量之间进行赋值

如果传递的是原始类型的值

​		修改一个变量，另一个变量是不会收到影响到，其实是复制了一个【副本】给对象

如果传递的是引用类型的对象：js中 不是原始类型就是引用类型

修改一个变量，另一个变量其实也会受到影响，因为大家操作的其实是同一个【地址值】–浅拷贝

### 编码和解码

```
编码:var code=encodeURIComponent("剑风传奇");
解码: var 原文=decodeURIComponent(code);
```

其实这个东西在某次浏览器更新后，当前就淘汰了!浏览器现在自带此功能

### isFinite(num)

判断num是不是无穷大，true->有效数字，false->无穷大

那些会为false： NaN  Infinity  分母为0，所有有多个都为false，不能用来判断是不是NaN

## 分支结构

swith...case...

语法：

```
switch(变量/表达式){
	case值1:
	操作1;
	case值2:
	操作2;
	default:
	默认操作;
}
```

特殊：

​	1、case的比较是不带隐式转换的

​	2、问题:默认只要一个case满足后，会将后面所有的操作全部做完

​			解决:break;

​			建议：每个case都加上break；

​	有的地方也可以省略break :
​		1、最后的一个操作default可以省略break
​		2、如果中间多个条件，做的操作是一样的，也可以省略掉中间的操作

​	3、default可以省略不写，如果条件都不满足的情况，则什么事都不会执行

#### 【面试题】 if   vs    switch

1、 switch:好处:执行效率相对较高
					缺点:必须要知道最后的结果才能使用，不能做范围判断
2、if:		好处:可以做范围判断

​				  缺点:执行效率相对较低

开发时:用哪个都无所谓
代码优化:尽量的将if换成switch

## 拓展JS动画

几乎和js无关，与css有关(transition过度)

JS操作样式:瞬间生效的，只需要加上过度就会慢慢生效

### animate.css动画库



## 循环结构

### do...while

```
var 循环变量 = 几;
do{
	循环体;
	循环变量的变化;
}while(循环条件)
```

### 【面试题】while和do...while的区别

除了写法上有区别，还有—个点:只看第一次
如果第—次大家都满足，两者其实没区别
如果第一次大家都不满足。while—次都不会执行，而do...while至少会执行—次

建议:优先使用for循环，不确定循环次数的时候再用while补充

## 终止循环语句

break  退出//退出整个循环

continue	继续//退出本次循环，还会继续做下一次

## 数组的基础

一个变量名可以保存多个数据

### 创建数组：2种

1、直接量数组

```
var arr=[];//空数组  其实[]的方式是ES3才带来的，原来只有用new Array才能创建数组
var arr=[数据1，数据2...];
```

2、构造函数方式

```
var arr=new Array();
```

### 【面试题】new Array(3)是什么意思 

创建一个长度为3的空数组

### 获取数组的数据

```
数组名[下标]-某个元素;
```

特殊：读取元素，下标越界 - 返回undefined

​			添加元素，下标越界 -稀疏数组

### 添加/替换

```
数组名[下标]=新值;
下标处有没有元素，如果没有则为添加，如果有了就替换
```

### 数组三大不限制

1、不限制元素个数

2、不限制元素类型

3、不限制元素的下标越界

​		如果获取元素，下标越界，返回的一个undefined

​		如果添加元素，下标越界，会得到一个稀疏数组，导致下标不再连续，如果搭配上循环去遍历每一个元素的话，我们会得到很多很多的undefined



解决：数组中唯一的属性：长度-获取当前数组的长度：最大下标+1

```
数组名.length
```

固定方法：

1、获取倒数第n个元素：

```
arr[arr.length-n];
```

2、始终向末尾添加元素：

```
arr[arr.length]=新值;
```

3、缩容：删除倒数n个元素

```
arr.length-=n;
```

往往很多情况，我们不会拿出某个元素来使用，而是拿出所有的每个元素来进行相同或相似的操作

### 遍历数组

```
for(var i=0;i<数组名.length;i++){
	console.log(数组名.[i])
}
```

释放一个引用类型的对象:切记一定要看清楚这个对象有几个变量关联着，每个变厘都要释放后才能真正的释放

最好的方式就是封装为一个函数，因为函数中的东西，调用完毕会自动释放

### 索引数组

下标都是数字组成的数组-默认

### 关联(hash)数组

下标是可以自定义的数组

为什么要自定义下标:索引数组的下标无具体的意义，不便于我们查找

#### 如果创建

1、先创建一个空数组：var arr=[]；

2、添加自定义下标并且赋值:arr["自定义下标"]=新值;

#### 访问

```
arr["自定义下标"];
```

#### 遍历

问题:不能使用for循环去遍历关联数组，因为length失效了，关联数组的length永远为O，而且我们下标也不再是一个数字

遍历:把数组中的每一个元紊取出来执行相同或相似的操作

解决：for in 循环

​	个人不爱称呼他叫做一个循环，因为不能设置从哪里开始到哪里结束，所有的操作都是自动的

语法：

```
for(var i in数组名){
	i;//自动得到每一个小标
	数组名[i];//当前hash数组中的元索了
}
既可以遍历哈希数组，又可以遍历索引数组
```

JS中除了undefined和null不是一个对象，万物皆对象，而【一切对象的底层都是hash数组】

#### 面试: *hash数组的原理:

hash算法：将字符串交给hash算法，会得到一个尽量不重复的数字，但是字符串的内容相同，那么得到的数字也一定是相同

添加元素：将自定义下标交给hash算法，得到一个数字(地址值)，把要保存的数据放进去

读取元素：将指定的自定义下标交给hash算法，得到一个和添加时完全相同的数字(地址值)，通过这个地址值可以拿到当初保存的东西

## 数组的API

### 数组转字符串

```
var str=arr.join("自定义连接符");
```

特殊：
	1、如果没有传入实参，则和toString效果一致，默认都是用，隔开

​	2、【面试笔试题】无缝连接

```
var arr=["h","e","l","l","o"]
arr.join("")
```

3、***将数组元素拼接为页面元素（数据渲染)

```
/获取数据
var arr=["-请选择-","北京","东京"]
//将数组转为了字符串，并且拼接上了标签
var str=" <optiop>"+arr.join(" </option> <option>")+"</option>";1/让字符串上DOM树, innerHTMIL是识别标签
sel.innerHTML=str;
```

#### 二级联动

1、必须使用二维数组，细分每一个城市，并且二维数组的顺序要和之前的一维数组对应

2、select.onchange=function(){} - 状态改变事件：只有选中项发生变化时，才会触发

3、select可以直接获取当前选中项的下标，而不需要自定义下标，select.selectedIndex

4、其实绑定事件，等号左边部分就是你的函数名

### 拼接数组

添加原始到末尾的新方式

```
var newArr=arr.concat(值1,值2...)
```

特殊：

1、此方法不会修改原数组，必须拿一个变量接住结果(返回一个新数组)

2、哪怕拼接的时一个数组，悄悄的打散数组，单个添加

### 截取子数组

```
var newArr=arr.slice(starti,endi+1)
```

特殊：

1、此方法不会修改原数组，必须拿一个变量接住结果(返回一个新数组)

2、含头不含尾

3、如果只传入了一个实参，则为从Starti开始到末尾

#### <font color=red>深拷贝</font>

4、如果两个实参都省略，则复制了一份 -深拷贝  两者互不影响

5、支持负数参数，-1代表倒数第—个，-n代表倒数第n个

以上的API都是不修改原数组的-------------------------------------以下的API都是修改原数组的

### 删插替 splice

#### 删除

```
arr.splice(starti,n)//从starti位置开始删除
var dels=arr.splice(starti,n)
```

特殊：返回的是你删除的元素组成的数组-有可能你删除的正好是你需要的

#### 插入

```
arr.splice(starti,0,新值1,新值2....)
var newArr=arr.splice(starti,0,新值1,新值2....)
```

特殊:1、原来starti位置的元紊以及后续元系都会被向后移动
2、没有删除元素，也有返回值，返回的是一个空数组而已

#### 替换

```
var newArr=arr.splice(starti,n,新值1,新值2....)
```

特殊：删除的个数和插入的个数不必相同

#### 翻转数组

```
arr.reverse(); -一仅仅只能翻转
```



## Array的API

### 排序

笔试中：手写冒泡排序：从第一个元素开始，依次比较两个相邻的元素，如果前一个>后一个，两者就要交换位置

```
for(varj=1<arr.length;j++)i
	for(var i=O;i<arr.length-j;i++){
	if(arr[i]>arr[i+1]){	
	var m=arr[i];
	arr[i]=arr[i+1];
	arr[i+1]=m;
	}
}
```

数组提供了—个排序APl–正式开发:
语法: 

```
arr.sort();
```

特殊
1、默认转为字符串，按位pk每个字符的unicode(ASCII)

2、希望按照数字排序 - 升序

```
arr.sort(function(a,b){
	return a-b;
})
```

3、希望按照数字排序 - 降序

```
arr.sort(function(a,b){
	return b-a;
})
```

切记：以后网页看到任何带有排序功能的特效，说明它的底层一定是数组，因为JS中只有数组可以排序，先排序再数据渲染

## 栈和队列

添加元素和删除元素的新方式

栈:一端封闭，只能从另一端进出

队列:只能—端进入,另一端出

#### 栈

开头入

```
arr.unshift(新值,....)
```

开头出

```
var first = arr.shift();//一次只能删除一个，而且一定是删除的第一个元素，有可能删除的东西就是你需要的东西个人不喜欢:
```

开头进出，会导致每个元素的下标都会发生变化

尾入

```
arr.push();
```

尾出

```
var last=arr.pop()//一次只能删除一个，而且一定是删除的最后一个元素，有可能删除的东西就是你需要的东西至少不会影响到其他人的位置
```

## 拓展：周期性定时器

开启：

```
timer=setInterval(function(){
	操作
},间隔的毫秒数)
```

停止：

```
clearInterval(定时器名)
```

鼠标移入

```
elem.onmouseover=function(){
	clearInterval(定时器名)
}
```

鼠标移出

```
elem.onmouseout=function(){
	操作
}
```

## 二维数组

数组的元素，又一次引用了一个数组

### 何时使用

你希望再一个数组内再次细分分类如何使用:

```
var peoples=[
	["吴飞华".18,"洪兴"],
	["“冯伟朕",19,"东英"],
	["封永跃",20."三联"]
];
```

### 访问

```
arr[r][c]--r代表下标，c代表列下标
```

### 特殊

1、列下标越界，返回undefined

2、行下标越界，返回报错，因为行下标越界已经得到undefined再加[]则报错

### 如何遍历

```
固定公式:外层循环遍历行，内层循环遍历列
for(var r=0;r<peoples.length;r++){
	for(var c=0;c<peoples[r].length;c++){
  console.log(peoples[r][c])
}

```

### 总结：ES3提供的数组

1、数组的基础(创建、访问、添加、遍历、hash数组)
2、数组的API(10个: join、concat、slice、splice、reverse、sort、push、pop、shift、unshif)3、二维数组

## String的基础概念

什么是字符串：多个字符组成的【只读】字符【数组】

​	1、【只读】:字符串所有的API都不会修改原字符串，只会返回新的字符串

​	2、【数组】︰跟数组有相同点:
​	1、字符串可以使用下标获取某个字符	2、字符串可以使用length获取字符的长度

​	3、字符串可以遍历得到每个字符
​	4、字符串可以使用数组不修改原数组的APl(concat,slice)

差异:所有数组直接修改原数组的API，字符串都不可以使用! 字符串自己也有一堆API等待我们下周学习

## JS内置对象(引用类型):11个

​	String Number   Boolean

​	Array	Funtion	Date(日期)	Math(数学运算) RegExp(正则：验证) 

Error(错误) 

Object(面向对象)

Global(全局对象)：

1、保存着全局变量和全局函数，只不过浏览器端/客户端/前端global被window代替了，以后我们学习Node.js后端语言的时候你会发全局真的是global

2、唯独window对象可以省略不写

## 概述

JavaScript：简称JS,是一个运行在客户端浏览器的【解释型】【弱类型】【面向对象】脚本语言

1.	编译型：在运行程序之前，需要先检查语法是否正确，如果不正确，直接不允许运行- 严格,不如：java/c++/c#...

​	    解释型：在运行程序之前，不需要先检查语法是否正确，直接运行，但是遇到错误后停止运行后续代码

2. 弱类型：变量保存的数据是可以随意的，数据类型是由数据来决定的 -更加的自由

​       强类型：变量保存的数据，是由数据类型来决定的  -Java -更加的严格

​	3.面向对象 - 很难

​			以后可能会经常看到一种写法

​	4.特点：

​			1.可以使用一切编辑器编写js代码，编辑器并不代表你的实力

​			2.解释型

​			3.弱类型

​			4.面向对象编程方式

​			5.可以做一切css完成不了的效果

## 组成

JavaScript其实由三部分组成

ECMAScript - 核心语法，以后js不管做什么操作可能都离不开它

DOM - Document  Object Model -文档对象模型，可以用js 来操作HTML和CSS

BOM - Browser Object Model - 浏览器对象模型，可以操作浏览器

## 如何使用JS

### 使用方式

​	1.使用方式：2种

​				1.直接在html页面上写一个script标签，里面就可以书写js代码

```
<script></script>
```

​				2.外部JS,进行引入 - 正式开发时使用

```
1)创建xx.js，里面书写js代码
2)在html页面引入
	<script src="js文件路径">
		只要有了src属性，此处就不可以在写代码了
	</script>
```

### 输出方式	

2.输出方式：帮助我们检查错误：3种

​			1、在控制台输出日志：

```
console.log(想要输出/查看的东西)
```

​			2、在页面上输出日志：

-缺点:如果绑定了点击事件，则之前的html+css消失了

-在页面上输出，而且支持识别标签

```
document.write(想要输出/查看的东西)
```

​			3、在弹出框输出日志：

-在浏览器自带的弹出框输出日志，但是弹出框会卡住页面，用户看到的只是白板

```
alert(想要输出/查看的东西)
```

### *变量和常量

​	*变量：创建后，值可以再次修改

​	何时使用：以后反复使用到的数据，都要提前把他保存在一个变量中，以后使用变量名，相当于就是在使用变量的值

​	如果使用：

```
var 变量名 = 值;
```

​	特殊：

​		1.变量名其实不是随意的

```
1.变量名其实不是随意的
2.不能以关键字命名
3.建议下划线命名法 或 小驼峰命名法
```

​		2.如果你的变量名是name，不管你保存的数据是什么数据类型，都会悄悄转换成字符串

​		3.多个变量创建可以简写：
​				var 变量名=值1，变量名=值2...;

​	常量：创建后，值不可以再次修改，只能设置一次值	

```
const 常量名 = 值;
```

### *算术运算符：+ - * / % 

​	1.%：读作取余，俗称模，两个数相除，不去商，而取除不尽的余数

​			固定套路：

​			1、判断奇偶性

​			2.获取一个数字的倒数n位

​	2.***特殊：其实算数运算符具有隐式类型转换，默认转为数字在运算

​			+运算：如果左右两边单反出现一个字符串，那么悄悄的转为字符串，+运算不再是+运算，而是拼接

​			- * / %：字符串也可以变为数字，但必须是纯数字组成的字符串 如果字符串包含了非数字字符，直接转为NaN: Not A Number (不是一个数但是是数字类型)



### *数据类型

原始/基本/值类型：5个

​		1、Number - 数字，取值：无数个

​		2、String - 字符串，取值：无数个，必须写上"" 或''

​		3、Boolean - 布尔 ，取值：两个：true/false -往往用于判断比较的条件处使用

​		4、Undefined - 取值：一个：undefined，创建了一个变量，但是没有赋值，默认值为undefined(祖师爷犯的错，用来做大部分操作都会报错！)

​		5、Null - 空 取值：1个：null，释放变量/内存，节约内存空间

引用/对象类型：11个引用类型的对象(很多很多的属性和方法)

### 分支结构

判断条件的不同选择对应的代码去执行，执行力一条路就不会再走别的路

#### 如何使用

​		一个条件，一件事，满足就做，不满足就不做

```
		if(判断条件){
			操作；
		}
```

​		一个条件，一件事，满足就做，不满足就做第二件

```
		if(判断条件){
        操作1；
		}else{
			操作2；
		}
```

​		多个条件，多件事，满足谁就做谁

```
		if(判断条件){
			操作1；
		}else if{
			操作2；
		}else{
			操作3；
		}
```

特殊：

​	1、else if...你想写多少个随便，根据你的需求自己判断

​	2、最后的else可以省略不写，如果条件都不满足，那么什么事都不会执行，分支白写

​	3、书写判断顺序，需要根据你的需求来写，不能乱写顺序

### 用户输入弹出框

```
var 变量名 = prompt("提示文字","默认值")
```

## 数据类型转换

不同的数据类型做操作可能出来的结果是不一样的

​	Number + Number = Number

​	Number + String = String

js获取页面上的一切东西，数据类型默认都是一个字符串

如果你想要查看数据类型：

```
typeof(想要查看的东西);
```

### 算数运算符的隐式转换

默认：算数运算符具有隐式类型转换，默认转为数字在运算

特殊：

​	1、+运算：如果左右两边单反出现一个字符串，那么悄悄的转为字符串，+运算不再是+运算，而是拼接

​	2、别的数据类型其实也可以转为数字

​			true->1   false->0    null->0     undefined->NaN

​	3、其实- * / %，字符串也可以转为一个数字，前提是一个纯数字组成的字符串

​	4、NaN: Not A Number：不是一个数字，但是确实是数据类型，不是一个有效数字

​			NaN的特点：

​			1.参与任何运算都是NaN

​			2.参与任何比较都是false

#### 如果判断NaN

​	问题：我们没有办法使用普通的比较方法判断数据是不是NaN

​	解决：

```
isNaN(x)
	true->是一个有效数字
	false->是一个无效数字
```

### 显示/强制转换

隐式转换出来的结果不是我们想要的，我们程序员就要手动调用一些方法，强制转为我们需要的类型，再做操作

#### 转字符串

```
var str=x.toString();//x不能是undefined或null，因为undefined和null不能使用任何的操作页面上的一切东西，数据类型默认都是一个字符串
```

#### 转数字

```
方法一:parseInt(str/num);  parse->解析 Int->整型
```

执行原理:专门为字符串和小数转为整数数字准备的，从左向右依次读取每个字符，碰到非数字字符，就停止转换，如果一来就碰到不认识的，则为NaN

```
方法二:parseFloat(str);  parse->解析 float->浮点型
```

执行原理:几乎和parseInt一致，认识第一个小数点

```
方法三:Number(x) 
```

此方法是万能的，任何人都可以转为数字。。完全等效于隐式转换

## Function基础

函数，陈志文方法:需要提前【预定义】好，以后可以【反复使用】的【代码段】

### 如何使用

#### 1.定义/声明/创建函数

```
function 函数名(){	
	代码块
}
```

#### 2.调用/使用函数

```
1.要么在js中程序员直接写死，要执行几次:函数名()
2.交给用户绑定在某个元素上，写上点击事件，让用户来触发:
	<elem onclick="js代码">内容</elem>
```

#### 3.何时使用

1.不希望打开页面立刻执行，而需要是再使用 或 由用户来触发
2.希望能够反复执行，不用刷新页面

3.以后任何一个独立的功能体，都要单独封装为一个函数

4.函数的地位非常高，函数是第一扽公民地位，随时随地考虑能不能封装为一个函数，尤其是重复的代码

5.函数内的一切内存，函数调用完毕后都会自动释放

#### 4.带参数的函数

函数   参数

创建：形参：形式参数，其实就是一个变量，但是不需要写var，而且默认也没有保存任何值，默认值为undefined

```
function 函数名(形参,形参...){	
	函数体
}
```

使用：实参：实际参数，真正的值，需要再调用时再传入

```
函数名(实参,实参...)
```

特殊:1、传实参的顺序一定要和形参的顺序一一对应，并且数量也要对应
2、不是一定要带参数的函数才是好函数，具体情况，需要具体分析:
	如果你的函数体就是固定的-则普通函数
	如果你的函数体希望根据传入的实参不同，做的略微不同–则带有参数的函数

### 分支结构

#### 程序的流程控制语句:3种

1.顺序执行 - 默认,从上向下的依次执行

2.分支结构 - 通过条件的判断，选择部分代码执行

3.循环结构 - 通过条件的判断，选择要不要重复执行某些代码

#### 比较运算符

<  >   <=  >=  ==   !=

用于做判断/比较的

结果:一定是个布尔值

强调：如果你想要判断多个条件，绝对不能像小时候数学的写法：区间写法

#### 逻辑运算符

&&：与    -要求全部条件满足最后结果才为true，否则为false

||：或 	-要求全部条件不满足最后结果才为false，否则为true

！：颠倒布尔值

## 循环结构

反复执行【相同 或 相似】的操作

​	循环三要素：

​		1.循环条件：开始 - 结束，循环的次数

​		2.循环体：做的操作是什么

​		3.循环变量：记录着我们当前在哪一次，而且他会不断的变化，往往都会向着不满足循环条件进行

### while循环

```
var 循环变量=
while(循环条件){
	循环体;
	循环变量变化
}
```

执行原理：首先创建了循环变量，然后判断条件，如果条件满足，则做【一次】循环体操作，并不会退出循环，回头继续判断条件满足吗，如果满足，则再做【一次】直到循环条件不满足，再退出循环

宏观上感受循环一瞬间就结束了，但是微观上其实是【一次一次】执行的

特殊：

1、有的时候真可能不知道从何开始，到何处结束，死循环：永远不会停下

```
while(true){
	循环体;
}
```

2、退出循环语句：break - 只能在循环中使用，多半都是搭配死循环使用的

随机数公式：

```
parseInt(Math.random()*(max-min+1)+min)
```

### for循环

```
for(var 循环变量=x; 循环条件;变量的变化){
	循环体
}
```

同时支持死循环

```
for(;;){
}
```

面试题：while 和 for 的区别？

​		语法上有区别，但两者都能做到相同的操作

​		一般来说我们不确定循环次数的时候，会使用while死循环

​		一般来说我们确定循环次数的时候，会使用for循环

## 数组基础

变量其实就是我们的内存， 变量创建的越多，我们内存空间消耗越大，那么网站的性能就越差

数组：创建一个变量可以保存【多个数据】的集合

​	数组都是线性排列，除了第一个元素，每个元素都有唯一的前驱元素

​	除了最后一个元素，每个元素都有唯一的后继元素

每个元素都有自己的位置。称之为下标，下标从0开始，到最大长度-1

### 创建数组：2种

1、直接量数组

```
var arr=[];//空数组  其实[]的方式是ES3才带来的，原来只有用new Array才能创建数组
var arr=[数据1，数据2...];
```

2、构造函数方式

```
var arr=new Array();
```

### 获取数组的数据

```
数组名[下标];
```

### 添加/替换

```
数组名[下标]=新值;
下标处有没有元素，如果没有则为添加，如果有了就替换
```

### 数组三大不限制

1、不限制元素个数

2、不限制元素类型

3、不限制元素的下标越界

​		如果获取元素，下标越界，返回的一个undefined

​		如果添加元素，下标越界，会得到一个稀疏数组，导致下标不再连续，如果搭配上循环去遍历每一个元素的话，我们会得到很多很多的undefined



解决：数组中唯一的属性：长度-获取当前数组的长度：最大下标+1

```
数组名.length
```

固定方法：

1、获取倒数第n个元素：

```
arr[arr.length-n];
```

2、始终向末尾添加元素：

```
arr[arr.length]=新值;
```

3、缩容：删除倒数n个元素

```
arr.length-=n;
```

往往很多情况，我们不会拿出某个元素来使用，而是拿出所有的每个元素来进行相同或相似的操作

### 遍历数组

```
for(var i=0;i<数组名.length;i++){
	console.log(数组名.[i])
}
```

## DOM

文档对象模型：专门用于操作HTML文档的，提供一些属性和方法等待我们学习

### DOM树概念

DOM将我们的HTML看作是一个倒挂的树状结构，但是树根不是html标签，而是document对象

document对象是由浏览器js解释器自动生成的，一个网页只有一个document

作用：可以通过树根找到我们想要的任何一个DOM元素/节点/对象(属性和方法)

DOM会将页面上的每一个元素、属性、文本、注释都会当作一个DOM元素/节点/对象

### 查找元素

#### 通过ID查找元素

```
var elem=document.getElementById("id值")
特殊：
	1、返回值，找到了返回的是一个找到的DOM元素，没找到返回值是null
	2、找到多个相同的id，也只会返回第一个
	3、垃圾方法，一次只能操作一个
	4、其实根本不需要使用此方法，直接写ID也可以找到元素 - 偷懒的写法
```

#### 通过标签名查找元素

```
var elem=document/已经找到的父元素.getElementByTagName("标签名")
特殊：
	1、返回值：找到了返回的是一个类数组DOM集合(很想数组，都能用下标，都能用length，都能遍历)，没找到返回一个空集合
	2、*js不能直接操作DOM元素集合，只能直接操作DOM元素
		解决：要么使用下标拿到某一个元素，要么使用遍历拿到每一个元素
	3、不一定非要从document开始查找，如果document去找，会找到所有元素，可以换成我们已经找到的某个父元素，就只会找到这个父元素下面的元素
```



#### 通过class名查找元素

```
var elem=document/已经找到的父元素.getElementByClassName("标签名")
特殊：
	1、返回值：找到了返回的是一个类数组DOM集合(很想数组，都能用下标，都能用length，都能遍历)，没找到返回一个空集合
	2、*js不能直接操作DOM元素集合，只能直接操作DOM元素
		解决：要么使用下标拿到某一个元素，要么使用遍历拿到每一个元素
	3、不一定非要从document开始查找，如果document去找，会找到所有元素，可以换成我们已经找到的某个父元素，就只会找到这个父元素下面的元素
```

#### 通过关系查找元素

前提条件：必须先找到一个元素才可以调用关系网

```
父元素：elem.parentNode
子元素：elem.children
第一个儿子：elem.firstElementChild
最后一个儿子：elem.lastElementChild
前一个兄弟：elem.previousElementSibling
后一个兄弟：elem.nextElementSibling
```

### 操作元素

前提：找到元素才能操作元素：

```
<标签 属性名="属性名" style="样式">内容</标签>
```

#### 1、内容

​	1、innerHTML: 获取 和 设置 开始标签到结束标签之间的内容 - 支持识别标签

```
	获取: elem.innerHTML;
	设置:elem.innerHTML="新内容";
```

​	2、innerText: 获取 和 设置 开始标签到结束标签之间的文本 -不支持识别标签

```
	获取: elem.innerText;
	设置:elem.innerText="新内容";
```

​	以上两个属性都是为双标签准备的，但是操作不了单标签input的内容

​	3、value:专门为input的value值准备的

```
	获取: input.value;
	设置:input.value="新内容";
```

#### 2、属性

```
	获取属性值:elem.getArrtibute("属性名");
	设置属性值:elem.getArrtibute("属性名","属性值");
	
	简化版：
	获取属性值:elem.("属性名");
	设置属性值:elem.属性名="新属性值";
			缺陷：
				1.class必须写为className -2015年过后，ES6诞生过后，class变成一个关键字
				2.不能操作自定义属性，只能操作标准属性
```

#### 3、样式

```
	获取/设置属性值:elem.style.css属性名="css属性值";
	特殊：
		1、css属性名，有横线的地方，去掉横线，变为小驼峰命名法
			border-radius -> borderRadius
		2、目前学习的，获取时，只能获取内联样式
```

#### 4.绑定事件

```
	elem.on事件名=function(){
			操作;
			this关键字：目前只能用于事件内;
					如果单个元素绑定事件:this->这个元素
					如果多个元素绑定事件:this->当前
	}
```

总结：

​	获取 --往往都是用于判断，比较

​	设置 --就是修改/添加


计算字符串：脱掉字符串的外套

```
eval("")
```

eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。

如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。

![](https://1217944250.github.io/veicos.github.io/imgs/1.png)

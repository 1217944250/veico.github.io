# Day021

## 概述

JavaScript：简称JS,是一个运行在客户端浏览器的【解释型】【弱类型】【面向对象】脚本语言

1.	编译型：在运行程序之前，需要先检查语法是否正确，如果不正确，直接不允许运行- 严格,不如：java/c++/c#...

​	    解释型：在运行程序之前，不需要先检查语法是否正确，直接运行，但是遇到错误后停止运行后续代码

2. 弱类型：变量保存的数据是可以随意的，数据类型是由数据来决定的 -更加的自由

​       强类型：变量保存的数据，是由数据类型来决定的  -Java -更加的严格

​	3.面向对象 - 很难

​			以后可能会经常看到一种写法

​	4.特点：

​			1.可以使用一切编辑器编写js代码，编辑器并不代表你的实力

​			2.解释型

​			3.弱类型

​			4.面向对象编程方式

​			5.可以做一切css完成不了的效果

## 组成

JavaScript其实由三部分组成

ECMAScript - 核心语法，以后js不管做什么操作可能都离不开它

DOM - Document  Object Model -文档对象模型，可以用js 来操作HTML和CSS

BOM - Browser Object Model - 浏览器对象模型，可以操作浏览器

## 如何使用JS

### 使用方式

​	1.使用方式：2种

​				1.直接在html页面上写一个script标签，里面就可以书写js代码

```
<script></script>
```

​				2.外部JS,进行引入 - 正式开发时使用

```
1)创建xx.js，里面书写js代码
2)在html页面引入
	<script src="js文件路径">
		只要有了src属性，此处就不可以在写代码了
	</script>
```

### 输出方式	

2.输出方式：帮助我们检查错误：3种

​			1、在控制台输出日志：

```
console.log(想要输出/查看的东西)
```

​			2、在页面上输出日志：

-缺点:如果绑定了点击事件，则之前的html+css消失了

-在页面上输出，而且支持识别标签

```
document.write(想要输出/查看的东西)
```

​			3、在弹出框输出日志：

-在浏览器自带的弹出框输出日志，但是弹出框会卡住页面，用户看到的只是白板

```
alert(想要输出/查看的东西)
```

### *变量和常量

​	*变量：创建后，值可以再次修改

​	何时使用：以后反复使用到的数据，都要提前把他保存在一个变量中，以后使用变量名，相当于就是在使用变量的值

​	如果使用：

```
var 变量名 = 值;
```

​	特殊：

​		1.变量名其实不是随意的

```
1.变量名其实不是随意的
2.不能以关键字命名
3.建议下划线命名法 或 小驼峰命名法
```

​		2.如果你的变量名是name，不管你保存的数据是什么数据类型，都会悄悄转换成字符串

​		3.多个变量创建可以简写：
​				var 变量名=值1，变量名=值2...;

​	常量：创建后，值不可以再次修改，只能设置一次值	

```
const 常量名 = 值;
```

### *算术运算符：+ - * / % 

​	1.%：读作取余，俗称模，两个数相除，不去商，而取除不尽的余数

​			固定套路：

​			1、判断奇偶性

​			2.获取一个数字的倒数n位

​	2.***特殊：其实算数运算符具有隐式类型转换，默认转为数字在运算

​			+运算：如果左右两边单反出现一个字符串，那么悄悄的转为字符串，+运算不再是+运算，而是拼接

​			- * / %：字符串也可以变为数字，但必须是纯数字组成的字符串 如果字符串包含了非数字字符，直接转为NaN: Not A Number (不是一个数但是是数字类型)



### *数据类型

原始/基本/值类型：5个

​		1、Number - 数字，取值：无数个

​		2、String - 字符串，取值：无数个，必须写上"" 或''

​		3、Boolean - 布尔 ，取值：两个：true/false -往往用于判断比较的条件处使用

​		4、Undefined - 取值：一个：undefined，创建了一个变量，但是没有赋值，默认值为undefined(祖师爷犯的错，用来做大部分操作都会报错！)

​		5、Null - 空 取值：1个：null，释放变量/内存，节约内存空间

引用/对象类型：11个引用类型的对象(很多很多的属性和方法)

### 分支结构

判断条件的不同选择对应的代码去执行，执行力一条路就不会再走别的路

#### 如何使用

​		一个条件，一件事，满足就做，不满足就不做

```
		if(判断条件){
			操作；
		}
```

​		一个条件，一件事，满足就做，不满足就做第二件

```
		if(判断条件){
        操作1；
		}else{
			操作2；
		}
```

​		多个条件，多件事，满足谁就做谁

```
		if(判断条件){
			操作1；
		}else if{
			操作2；
		}else{
			操作3；
		}
```

特殊：

​	1、else if...你想写多少个随便，根据你的需求自己判断

​	2、最后的else可以省略不写，如果条件都不满足，那么什么事都不会执行，分支白写

​	3、书写判断顺序，需要根据你的需求来写，不能乱写顺序

### 用户输入弹出框

```
var 变量名 = prompt("提示文字","默认值")
```

# Day022

## 数据类型转换

不同的数据类型做操作可能出来的结果是不一样的

​	Number + Number = Number

​	Number + String = String

js获取页面上的一切东西，数据类型默认都是一个字符串

如果你想要查看数据类型：

```
typeof(想要查看的东西);
```

### 算数运算符的隐式转换

默认：算数运算符具有隐式类型转换，默认转为数字在运算

特殊：

​	1、+运算：如果左右两边单反出现一个字符串，那么悄悄的转为字符串，+运算不再是+运算，而是拼接

​	2、别的数据类型其实也可以转为数字

​			true->1   false->0    null->0     undefined->NaN

​	3、其实- * / %，字符串也可以转为一个数字，前提是一个纯数字组成的字符串

​	4、NaN: Not A Number：不是一个数字，但是确实是数据类型，不是一个有效数字

​			NaN的特点：

​			1.参与任何运算都是NaN

​			2.参与任何比较都是false

#### 如果判断NaN

​	问题：我们没有办法使用普通的比较方法判断数据是不是NaN

​	解决：

```
isNaN(x)
	true->是一个有效数字
	false->是一个无效数字
```

### 显示/强制转换

隐式转换出来的结果不是我们想要的，我们程序员就要手动调用一些方法，强制转为我们需要的类型，再做操作

#### 转字符串

```
var str=x.toString();//x不能是undefined或null，因为undefined和null不能使用任何的操作页面上的一切东西，数据类型默认都是一个字符串
```

#### 转数字

```
方法一:parseInt(str/num);  parse->解析 Int->整型
```

执行原理:专门为字符串和小数转为整数数字准备的，从左向右依次读取每个字符，碰到非数字字符，就停止转换，如果一来就碰到不认识的，则为NaN

```
方法二:parseFloat(str);  parse->解析 float->浮点型
```

执行原理:几乎和parseInt一致，认识第一个小数点

```
方法三:Number(x) 
```

此方法是万能的，任何人都可以转为数字。。完全等效于隐式转换

## Function基础

函数，陈志文方法:需要提前【预定义】好，以后可以【反复使用】的【代码段】

### 如何使用

#### 1.定义/声明/创建函数

```
function 函数名(){	
	代码块
}
```

#### 2.调用/使用函数

```
1.要么在js中程序员直接写死，要执行几次:函数名()
2.交给用户绑定在某个元素上，写上点击事件，让用户来触发:
	<elem onclick="js代码">内容</elem>
```

#### 3.何时使用

1.不希望打开页面立刻执行，而需要是再使用 或 由用户来触发
2.希望能够反复执行，不用刷新页面

3.以后任何一个独立的功能体，都要单独封装为一个函数

4.函数的地位非常高，函数是第一扽公民地位，随时随地考虑能不能封装为一个函数，尤其是重复的代码

5.函数内的一切内存，函数调用完毕后都会自动释放

#### 4.带参数的函数

函数   参数

创建：形参：形式参数，其实就是一个变量，但是不需要写var，而且默认也没有保存任何值，默认值为undefined

```
function 函数名(形参,形参...){	
	函数体
}
```

使用：实参：实际参数，真正的值，需要再调用时再传入

```
函数名(实参,实参...)
```

特殊:1、传实参的顺序一定要和形参的顺序一一对应，并且数量也要对应
2、不是一定要带参数的函数才是好函数，具体情况，需要具体分析:
	如果你的函数体就是固定的-则普通函数
	如果你的函数体希望根据传入的实参不同，做的略微不同–则带有参数的函数

### 分支结构

#### 程序的流程控制语句:3种

1.顺序执行 - 默认,从上向下的依次执行

2.分支结构 - 通过条件的判断，选择部分代码执行

3.循环结构 - 通过条件的判断，选择要不要重复执行某些代码

#### 比较运算符

<  >   <=  >=  ==   !=

用于做判断/比较的

结果:一定是个布尔值

强调：如果你想要判断多个条件，绝对不能像小时候数学的写法：区间写法

#### 逻辑运算符

&&：与    -要求全部条件满足最后结果才为true，否则为false

||：或 	-要求全部条件不满足最后结果才为false，否则为true

！：颠倒布尔值

# Day023

## 循环结构

反复执行【相同 或 相似】的操作

​	循环三要素：

​		1.循环条件：开始 - 结束，循环的次数

​		2.循环体：做的操作是什么

​		3.循环变量：记录着我们当前在哪一次，而且他会不断的变化，往往都会向着不满足循环条件进行

### while循环

```
var 循环变量=
while(循环条件){
	循环体;
	循环变量变化
}
```

执行原理：首先创建了循环变量，然后判断条件，如果条件满足，则做【一次】循环体操作，并不会退出循环，回头继续判断条件满足吗，如果满足，则再做【一次】直到循环条件不满足，再退出循环

宏观上感受循环一瞬间就结束了，但是微观上其实是【一次一次】执行的

特殊：

1、有的时候真可能不知道从何开始，到何处结束，死循环：永远不会停下

```
while(true){
	循环体;
}
```

2、退出循环语句：break - 只能在循环中使用，多半都是搭配死循环使用的

随机数公式：

```
parseInt(Math.random()*(max-min+1)+min)
```

### for循环

```
for(var 循环变量=x; 循环条件;变量的变化){
	循环体
}
```

同时支持死循环

```
for(;;){
}
```

面试题：while 和 for 的区别？

​		语法上有区别，但两者都能做到相同的操作

​		一般来说我们不确定循环次数的时候，会使用while死循环

​		一般来说我们确定循环次数的时候，会使用for循环

## 数组基础

变量其实就是我们的内存， 变量创建的越多，我们内存空间消耗越大，那么网站的性能就越差

数组：创建一个变量可以保存【多个数据】的集合

​	数组都是线性排列，除了第一个元素，每个元素都有唯一的前驱元素

​	除了最后一个元素，每个元素都有唯一的后继元素

每个元素都有自己的位置。称之为下标，下标从0开始，到最大长度-1

### 创建数组：2种

1、直接量数组

```
var arr=[];//空数组  其实[]的方式是ES3才带来的，原来只有用new Array才能创建数组
var arr=[数据1，数据2...];
```

2、构造函数方式

```
var arr=new Array();
```

### 获取数组的数据

```
数组名[下标];
```

### 添加/替换

```
数组名[下标]=新值;
下标处有没有元素，如果没有则为添加，如果有了就替换
```

### 数组三大不限制

1、不限制元素个数

2、不限制元素类型

3、不限制元素的下标越界

​		如果获取元素，下标越界，返回的一个undefined

​		如果添加元素，下标越界，会得到一个稀疏数组，导致下标不再连续，如果搭配上循环去遍历每一个元素的话，我们会得到很多很多的undefined



解决：数组中唯一的属性：长度-获取当前数组的长度：最大下标+1

```
数组名.length
```

固定方法：

1、获取倒数第n个元素：

```
arr[arr.length-n];
```

2、始终向末尾添加元素：

```
arr[arr.length]=新值;
```

3、缩容：删除倒数n个元素

```
arr.length-=n;
```

往往很多情况，我们不会拿出某个元素来使用，而是拿出所有的每个元素来进行相同或相似的操作

### 遍历数组

```
for(var i=0;i<数组名.length;i++){
	console.log(数组名.[i])
}
```

# Day024

## DOM

文档对象模型：专门用于操作HTML文档的，提供一些属性和方法等待我们学习

### DOM树概念

DOM将我们的HTML看作是一个倒挂的树状结构，但是树根不是html标签，而是document对象

document对象是由浏览器js解释器自动生成的，一个网页只有一个document

作用：可以通过树根找到我们想要的任何一个DOM元素/节点/对象(属性和方法)

DOM会将页面上的每一个元素、属性、文本、注释都会当作一个DOM元素/节点/对象

### 查找元素

#### 通过ID查找元素

```
var elem=document.getElementById("id值")
特殊：
	1、返回值，找到了返回的是一个找到的DOM元素，没找到返回值是null
	2、找到多个相同的id，也只会返回第一个
	3、垃圾方法，一次只能操作一个
	4、其实根本不需要使用此方法，直接写ID也可以找到元素 - 偷懒的写法
```

#### 通过标签名查找元素

```
var elem=document/已经找到的父元素.getElementByTagName("标签名")
特殊：
	1、返回值：找到了返回的是一个类数组DOM集合(很想数组，都能用下标，都能用length，都能遍历)，没找到返回一个空集合
	2、*js不能直接操作DOM元素集合，只能直接操作DOM元素
		解决：要么使用下标拿到某一个元素，要么使用遍历拿到每一个元素
	3、不一定非要从document开始查找，如果document去找，会找到所有元素，可以换成我们已经找到的某个父元素，就只会找到这个父元素下面的元素
```



#### 通过class名查找元素

```
var elem=document/已经找到的父元素.getElementByClassName("标签名")
特殊：
	1、返回值：找到了返回的是一个类数组DOM集合(很想数组，都能用下标，都能用length，都能遍历)，没找到返回一个空集合
	2、*js不能直接操作DOM元素集合，只能直接操作DOM元素
		解决：要么使用下标拿到某一个元素，要么使用遍历拿到每一个元素
	3、不一定非要从document开始查找，如果document去找，会找到所有元素，可以换成我们已经找到的某个父元素，就只会找到这个父元素下面的元素
```

#### 通过关系查找元素

前提条件：必须先找到一个元素才可以调用关系网

```
父元素：elem.parentNode
子元素：elem.children
第一个儿子：elem.firstElementChild
最后一个儿子：elem.lastElementChild
前一个兄弟：elem.previousElementSibling
后一个兄弟：elem.nextElementSibling
```

### 操作元素

前提：找到元素才能操作元素：

```
<标签 属性名="属性名" style="样式">内容</标签>
```

#### 1、内容

​	1、innerHTML: 获取 和 设置 开始标签到结束标签之间的内容 - 支持识别标签

```
	获取: elem.innerHTML;
	设置:elem.innerHTML="新内容";
```

​	2、innerText: 获取 和 设置 开始标签到结束标签之间的文本 -不支持识别标签

```
	获取: elem.innerText;
	设置:elem.innerText="新内容";
```

​	以上两个属性都是为双标签准备的，但是操作不了单标签input的内容

​	3、value:专门为input的value值准备的

```
	获取: input.value;
	设置:input.value="新内容";
```

#### 2、属性

```
	获取属性值:elem.getArrtibute("属性名");
	设置属性值:elem.getArrtibute("属性名","属性值");
	
	简化版：
	获取属性值:elem.("属性名");
	设置属性值:elem.属性名="新属性值";
			缺陷：
				1.class必须写为className -2015年过后，ES6诞生过后，class变成一个关键字
				2.不能操作自定义属性，只能操作标准属性
```

#### 3、样式

```
	获取/设置属性值:elem.style.css属性名="css属性值";
	特殊：
		1、css属性名，有横线的地方，去掉横线，变为小驼峰命名法
			border-radius -> borderRadius
		2、目前学习的，获取时，只能获取内联样式
```

#### 4.绑定事件

```
	elem.on事件名=function(){
			操作;
			this关键字：目前只能用于事件内;
					如果单个元素绑定事件:this->这个元素
					如果多个元素绑定事件:this->当前
	}
```

总结：

​	获取 --往往都是用于判断，比较

​	设置 --就是修改/添加

# Day025

## eval函数

计算字符串：脱掉字符串的外套

```
eval("")
```

eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。

如果参数是一个表达式，eval() 函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。

![1](D:\train\note\javascript\imgs\1.png)

# Day026

## 数据类型转换

### 强制转换

#### 转字符

```
var str=x.toString();//x不能是undefined或null，因为undefined和null不能使用任何的操作页面上的一切东西，数据类型默认都是一个字符串
```

#### 转数字

```
方法一:parseInt(str/num);  parse->解析 Int->整型
```

执行原理:专门为字符串和小数转为整数数字准备的，从左向右依次读取每个字符，碰到非数字字符，就停止转换，如果一来就碰到不认识的，则为NaN

```
方法二:parseFloat(str);  parse->解析 float->浮点型
```

执行原理:几乎和parseInt一致，认识第一个小数点

```
方法三:Number(x) 
```

此方法是万能的，任何人都可以转为数字。。完全等效于隐式转换

#### 转布尔

```
Boolean();
只有六个会为false
Boolean(0);
Boolean("");
Boolean(undefined);
Boolean(null);
Boolean(NaN);
Boolean(flase);
```

在分支/循环的条件之中，自动隐式转换，以后不管在条件里面写的有多奇怪，你都要知道他会悄悄的变成一个不二值，你只需要判断true 还是 false

### 隐式转换

都是出现在运算符之中

## 运算符和表达式

### 算数运算符

 + - * /  %



### 比较运算符

<  >   <=  >=  ==   !=  ===   !===

用于做判断/比较的

结果:一定是个布尔值

隐式转换：转成数字再比较

特殊：

​	1.如果参与比较的左右两边都是字符串，则按位pk每个字符的十六进制的unicode号(十进制ASCII码)

​		0-9<A-Z<a-z<汉字：常识：汉字的第一个字：一：unicode号：4e00 - ascii：19968 汉字的最后一个字：龥：unicode号：9fa5 -ascii：40869

​	2.NaN参与任何比较运算结果都为false，所以没有办法使用普通的比较运算来判断x是不是NaN

```
!isNaN(x);
```

​	3.undefined==null;//true

区分：undefined===null;

全等：=== -要求数值相同，并且数据类型也要相同，不再带有隐式转换

!== - 不再带有隐式转换的不等比较

重写String方法，看出==和===的区别

```
function String(x){
	if(x===undefined){
		return "undefined";//return->返回，后面跟着的就是返回的结果
	}else if(x===null){
		return "null";
	}else{
		return x.toString(;
	}
}
```

### 逻辑运算符

作用：综合比较，结果也是布尔值

隐式转换：左右两边都会悄悄转为布尔值，再综合比较结果

&&：与    -要求全部条件满足最后结果才为true，否则为false

||：或 	-要求全部条件不满足最后结果才为false，否则为true

！：颠倒布尔值

特殊：短路逻辑：如果前一个条件，已经可以得出最终结果了，没有必要看后续

#### &&短路

​	&&短路：如果前一个条件满足，才执行后一个条件，如果前一个条件不满足，则不管后续条件

​		目的：简化简单的分支：1、一个条件一件事，满足就做，不满足就不做	2、操作只能有一句话：多句操作导致我们以后维护目的观看

​		语法：

```
条件&&(操作);
```

#### ||短路

实现浏览器兼容性问题：二选一

​	e=e || window.event；

### 位运算

左移：m<<n,读作m左移了n位，翻译：m*2的n次方

左移：m>>n,读作m右移了n位，翻译：m/2的n次方

### 赋值运算

+= -= *= /= %= ++ --

​	一句话完成两个操作，先计算，在赋值回去

##### 【面试题】

i++ 和++i的区别

单独使用时，放前放后无所谓效果一样
但是如果参与了别的表达式，变量中的值都会＋1
前++【返回的是加了过后】的新值

后++【返回的是加了过前】的旧值

### 三目运算

简化if...else...     if...else if...else

三目运算符：又称之为三元[运算符](https://so.csdn.net/so/search?q=运算符&spm=1001.2101.3001.7020)

格式：

```
(关系表达式)?表达式1:默认操作;
(关系表达式1)?表达式1:(关系表达式2)?表达式2:默认操作;
```

如果关系表达式的结果为true，运算后的结果是表达式1；

如果关系表达式的结果为false，运算后的结果是表达式2；

特殊

​	1、默认操作不能省略，省略会报错

​	2、如果操作有多句话，还是推荐分支

总结:

```
if			===&&短路
if...else	===三目运算
if...else if...else===三目运算
操作多句话使用以上三个
操作一句话使用以上3个
```

### 拓展

1、计算机很笨，牛逼在快和记忆力好(机械硬盘-永久保存，固态硬盘-只能保存10年):计算机带有摄入误差

解决：num.toFixed(d)d代表保留小数位，会四舍五入

缺陷：返回的是要字符串，建议搭配parseFloat食用

2、

### 获取字符串中第一个字符的ASCII码

```
elem.charCodeAt(0);
```

# Day027

## 函数

也叫做方法，是需要预定义好的，以后可以反复使用的代码段

### 创建函数并且调用

#### 声明方式创建函数

用一个关键字function做声明

```
	function 函数名(形参列表){
		函数体;
		return 返回值;
	}
```

调用函数：函数名(实参列表)

#### 直接量方式创建函数

函数名其实就是一个变量名

	var 函数名=function(形参列表){
		函数体;
		return 返回值;
	}

return的本意是退出函数

只不过如果return后面跟着一个数据，会顺便将其返回到全局作用域中，但是只负责返回不负责保存

所以在调用函数时:如果有return，记得拿个变量接住结果



### 作用域

#### 全局作用域

全局变量和全局函数，在任何地方都可以使用

#### 函数/局部作用域

局部变量和局部函数，在【函数调用】时内部可用

<font color="red">带来了变量的使用规则:优先使用局部的，局部没有找全局，全局没有就报错</font>

特殊：

​	1、千万不要对着未声明的变量直接赋值，导致全局污染，全局本来没有的东西，突然被添加一坨内存，建议创建变量时，记得一定要写var

​	2、儿子不孝啊:局部的东西全局居然不能用，解决:看上面

​	3、哪怕没有写return，其实最后也有return值，只不过是一个return undefined

​	4、return一般只会出现在函数的最后，而且只能出现一个

​	5、往往前辈们提供的方法，底层都有一个return操作，前辈们觉得以后用这些方法的人，可能还需要拿着这个结果去做别的操作

#### 声明提前(笔试重点)

真正开发不会用

原理：

在程序正式执行之前，

会将var声明的变量和function声明的函数，

集中提前到当前作用域的顶部，

变量比函数轻，但是赋值留在原地



明说:自己写代码绝对不会碰到，只要我们遵守原则:1、先创建后使用2、变量名和函数名尽量的不要重复只有鄙视中碰到，如果你以后碰到先使用在创建，或者经常重复变量名，很有可能就是在考你声明提前
先转为我们提前后的样子，再去判断

### 按值传递

两个变量之间进行赋值

如果传递的是原始类型的值

​		修改一个变量，另一个变量是不会收到影响到，其实是复制了一个【副本】给对象

如果传递的是引用类型的对象：js中 不是原始类型就是引用类型

修改一个变量，另一个变量其实也会受到影响，因为大家操作的其实是同一个【地址值】–浅拷贝

## 预定义全局函数

前辈们提前写好的，我们程序员可以直接使用的，全局(在仍地方都可以使用)

### 编码和解码

问题:url中不允许出现多字节字符，如果出现会乱码
		utf-8编码格式下，一个汉字，占3字节
解决:发送前，前端将多字节字符编码为单字节字符（数字、字母)
		发送后，后端接住，然后将单字节字符解码为原文

如何：

```
编码:var code=encodeURIComponent("剑风传奇");
解码: var 原文=decodeURIComponent(code);
```

其实这个东西在某次浏览器更新后，当前就淘汰了!浏览器现在自带此功能

### isFinite(num)

判断num是不是无穷大，true->有效数字，false->无穷大

那些会为false： NaN  Infinity  分母为0，所有有多个都为false，不能用来判断是不是NaN

### 牛逼的

parselnt/Float、isNaN、 eval  --ECMASCRIRT
alertQ  		--bom
prompt		--bom

## 分支结构

swith...case...

语法：

```
switch(变量/表达式){
	case值1:
	操作1;
	case值2:
	操作2;
	default:
	默认操作;
}
```

特殊：

​	1、case的比较是不带隐式转换的

​	2、问题:默认只要一个case满足后，会将后面所有的操作全部做完

​			解决:break;

​			建议：每个case都加上break；

​	有的地方也可以省略break :
​		1、最后的一个操作default可以省略break
​		2、如果中间多个条件，做的操作是一样的，也可以省略掉中间的操作

​	3、default可以省略不写，如果条件都不满足的情况，则什么事都不会执行

#### 【面试题】 if   vs    switch

1、 switch:好处:执行效率相对较高
					缺点:必须要知道最后的结果才能使用，不能做范围判断
2、if:		好处:可以做范围判断

​				  缺点:执行效率相对较低

开发时:用哪个都无所谓
代码优化:尽量的将if换成switch

## 拓展JS动画

几乎和js无关，与css有关(transition过度)

JS操作样式:瞬间生效的，只需要加上过度就会慢慢生效

### animate.css动画库

# Day028

## 循环结构

### do...while

```
var 循环变量 = 几;
do{
	循环体;
	循环变量的变化;
}while(循环条件)
```

### 【面试题】while和do...while的区别

除了写法上有区别，还有—个点:只看第一次
如果第—次大家都满足，两者其实没区别
如果第一次大家都不满足。while—次都不会执行，而do...while至少会执行—次

建议:优先使用for循环，不确定循环次数的时候再用while补充

## 终止循环语句

break  退出//退出整个循环

continue	继续//退出本次循环，还会继续做下一次

## 数组的基础

一个变量名可以保存多个数据

### 创建数组：2种

1、直接量数组

```
var arr=[];//空数组  其实[]的方式是ES3才带来的，原来只有用new Array才能创建数组
var arr=[数据1，数据2...];
```

2、构造函数方式

```
var arr=new Array();
```

### 【面试题】new Array(3)是什么意思 

创建一个长度为3的空数组

### 获取数组的数据

```
数组名[下标]-某个元素;
```

特殊：读取元素，下标越界 - 返回undefined

​			添加元素，下标越界 -稀疏数组

### 添加/替换

```
数组名[下标]=新值;
下标处有没有元素，如果没有则为添加，如果有了就替换
```

### 数组三大不限制

1、不限制元素个数

2、不限制元素类型

3、不限制元素的下标越界

​		如果获取元素，下标越界，返回的一个undefined

​		如果添加元素，下标越界，会得到一个稀疏数组，导致下标不再连续，如果搭配上循环去遍历每一个元素的话，我们会得到很多很多的undefined



解决：数组中唯一的属性：长度-获取当前数组的长度：最大下标+1

```
数组名.length
```

固定方法：

1、获取倒数第n个元素：

```
arr[arr.length-n];
```

2、始终向末尾添加元素：

```
arr[arr.length]=新值;
```

3、缩容：删除倒数n个元素

```
arr.length-=n;
```

往往很多情况，我们不会拿出某个元素来使用，而是拿出所有的每个元素来进行相同或相似的操作

### 遍历数组

```
for(var i=0;i<数组名.length;i++){
	console.log(数组名.[i])
}
```

释放一个引用类型的对象:切记一定要看清楚这个对象有几个变量关联着，每个变厘都要释放后才能真正的释放

最好的方式就是封装为一个函数，因为函数中的东西，调用完毕会自动释放

### 索引数组

下标都是数字组成的数组-默认

### 关联(hash)数组

下标是可以自定义的数组

为什么要自定义下标:索引数组的下标无具体的意义，不便于我们查找

#### 如果创建

1、先创建一个空数组：var arr=[]；

2、添加自定义下标并且赋值:arr["自定义下标"]=新值;

#### 访问

```
arr["自定义下标"];
```

#### 遍历

问题:不能使用for循环去遍历关联数组，因为length失效了，关联数组的length永远为O，而且我们下标也不再是一个数字

遍历:把数组中的每一个元紊取出来执行相同或相似的操作

解决：for in 循环

​	个人不爱称呼他叫做一个循环，因为不能设置从哪里开始到哪里结束，所有的操作都是自动的

语法：

```
for(var i in数组名){
	i;//自动得到每一个小标
	数组名[i];//当前hash数组中的元索了
}
既可以遍历哈希数组，又可以遍历索引数组
```

JS中除了undefined和null不是一个对象，万物皆对象，而【一切对象的底层都是hash数组】

#### 面试: *hash数组的原理:

hash算法：将字符串交给hash算法，会得到一个尽量不重复的数字，但是字符串的内容相同，那么得到的数字也一定是相同

添加元素：将自定义下标交给hash算法，得到一个数字(地址值)，把要保存的数据放进去

读取元素：将指定的自定义下标交给hash算法，得到一个和添加时完全相同的数字(地址值)，通过这个地址值可以拿到当初保存的东西

## 数组的API

### 数组转字符串

```
var str=arr.join("自定义连接符");
```

特殊：
	1、如果没有传入实参，则和toString效果一致，默认都是用，隔开

​	2、【面试笔试题】无缝连接

```
var arr=["h","e","l","l","o"]
arr.join("")
```

3、***将数组元素拼接为页面元素（数据渲染)

```
/获取数据
var arr=["-请选择-","北京","东京"]
//将数组转为了字符串，并且拼接上了标签
var str=" <optiop>"+arr.join(" </option> <option>")+"</option>";1/让字符串上DOM树, innerHTMIL是识别标签
sel.innerHTML=str;
```

#### 二级联动

1、必须使用二维数组，细分每一个城市，并且二维数组的顺序要和之前的一维数组对应

2、select.onchange=function(){} - 状态改变事件：只有选中项发生变化时，才会触发

3、select可以直接获取当前选中项的下标，而不需要自定义下标，select.selectedIndex

4、其实绑定事件，等号左边部分就是你的函数名

### 拼接数组

添加原始到末尾的新方式

```
var newArr=arr.concat(值1,值2...)
```

特殊：

1、此方法不会修改原数组，必须拿一个变量接住结果(返回一个新数组)

2、哪怕拼接的时一个数组，悄悄的打散数组，单个添加

### 截取子数组

```
var newArr=arr.slice(starti,endi+1)
```

特殊：

1、此方法不会修改原数组，必须拿一个变量接住结果(返回一个新数组)

2、含头不含尾

3、如果只传入了一个实参，则为从Starti开始到末尾

#### <font color=red>深拷贝</font>

4、如果两个实参都省略，则复制了一份 -深拷贝  两者互不影响

5、支持负数参数，-1代表倒数第—个，-n代表倒数第n个

以上的API都是不修改原数组的-------------------------------------以下的API都是修改原数组的

### 删插替 splice

#### 删除

```
arr.splice(starti,n)//从starti位置开始删除
var dels=arr.splice(starti,n)
```

特殊：返回的是你删除的元素组成的数组-有可能你删除的正好是你需要的

#### 插入

```
arr.splice(starti,0,新值1,新值2....)
var newArr=arr.splice(starti,0,新值1,新值2....)
```

特殊:1、原来starti位置的元紊以及后续元系都会被向后移动
2、没有删除元素，也有返回值，返回的是一个空数组而已

#### 替换

```
var newArr=arr.splice(starti,n,新值1,新值2....)
```

特殊：删除的个数和插入的个数不必相同

#### 翻转数组

```
arr.reverse(); -一仅仅只能翻转
```

# Day029

## Array的API

### 排序

笔试中：手写冒泡排序：从第一个元素开始，依次比较两个相邻的元素，如果前一个>后一个，两者就要交换位置

```
for(varj=1<arr.length;j++)i
	for(var i=O;i<arr.length-j;i++){
	if(arr[i]>arr[i+1]){	
	var m=arr[i];
	arr[i]=arr[i+1];
	arr[i+1]=m;
	}
}
```

数组提供了—个排序APl–正式开发:
语法: 

```
arr.sort();
```

特殊
1、默认转为字符串，按位pk每个字符的unicode(ASCII)

2、希望按照数字排序 - 升序

```
arr.sort(function(a,b){//匿名回调函数，是不需要程序员调用的，而且都是前辈们提供好的，我们只需要学习如何使用即可
	return a-b;
	//a时后一个数，b是前一个数
	//如果a>b，就会返回一个正数，说明后一个数>前一个数
	//如果a<b，就会返回一个负数，说明后一个数<前一个数
	//如果a==b，就会返回一个0，说明后一个数==前一个数
	//sort的底层就能通过你返回的值来判断要不要帮你交换位置
})
```

3、希望按照数字排序 - 降序

```
arr.sort(function(a,b){
	return b-a;
})
```

切记：以后网页看到任何带有排序功能的特效，说明它的底层一定是数组，因为JS中只有数组可以排序，先排序再数据渲染

## 栈和队列

添加元素和删除元素的新方式

栈:一端封闭，只能从另一端进出

队列:只能—端进入,另一端出

#### 栈

开头入

```
arr.unshift(新值,....)
```

开头出

```
var first = arr.shift();//一次只能删除一个，而且一定是删除的第一个元素，有可能删除的东西就是你需要的东西个人不喜欢:
```

开头进出，会导致每个元素的下标都会发生变化

尾入

```
arr.push();
```

尾出

```
var last=arr.pop()//一次只能删除一个，而且一定是删除的最后一个元素，有可能删除的东西就是你需要的东西至少不会影响到其他人的位置
```

## 拓展：周期性定时器

开启：

```
timer=setInterval(function(){
	操作
},间隔的毫秒数)
```

停止：

```
clearInterval(定时器名)
```

鼠标移入

```
elem.onmouseover=function(){
	clearInterval(定时器名)
}
```

鼠标移出

```
elem.onmouseout=function(){
	操作
}
```

## 二维数组

数组的元素，又一次引用了一个数组

### 何时使用

你希望再一个数组内再次细分分类如何使用:

```
var peoples=[
	["吴飞华".18,"洪兴"],
	["“冯伟朕",19,"东英"],
	["封永跃",20."三联"]
];
```

### 访问

```
arr[r][c]--r代表下标，c代表列下标
```

### 特殊

1、列下标越界，返回undefined

2、行下标越界，返回报错，因为行下标越界已经得到undefined再加[]则报错

### 如何遍历

```
固定公式:外层循环遍历行，内层循环遍历列
for(var r=0;r<peoples.length;r++){
	for(var c=0;c<peoples[r].length;c++){
  console.log(peoples[r][c])
}

```

### 总结：ES3提供的数组

1、数组的基础(创建、访问、添加、遍历、hash数组)
2、数组的API(10个: join、concat、slice、splice、reverse、sort、push、pop、shift、unshif)3、二维数组

## String的基础概念

什么是字符串：多个字符组成的【只读】字符【数组】

​	1、【只读】:字符串所有的API都不会修改原字符串，只会返回新的字符串

​	2、【数组】︰跟数组有相同点:
​	1、字符串可以使用下标获取某个字符	2、字符串可以使用length获取字符的长度

​	3、字符串可以遍历得到每个字符
​	4、字符串可以使用数组不修改原数组的APl(concat,slice)

差异:所有数组直接修改原数组的API，字符串都不可以使用! 字符串自己也有一堆API等待我们下周学习

## JS内置对象(引用类型):11个

​	String Number   Boolean

​	Array	Funtion	Date(日期)	Math(数学运算) RegExp(正则：验证) 

Error(错误) 

Object(面向对象)

Global(全局对象)：

1、保存着全局变量和全局函数，只不过浏览器端/客户端/前端global被window代替了，以后我们学习Node.js后端语言的时候你会发全局真的是global

2、唯独window对象可以省略不写

### 包装类型

专门封装原始类型的值，将原类型悄悄的变成了引用类型的对象(属性和方法)

#### 为什么

前辈们觉得比如字符串经常会被我们拿来做一些操作，为了方便我们程序员，提供了包装类型，把字符串变成了一个对象，提供了我们一些操作字符串的同性和方法，本身原始类型的值，不带有任何属性和方法，意味着不能使用去做操作的

#### 何时使用

只要你试图使用.去操作原始类型的值的时候，包装类型就会悄悄出现

#### 何时释放

方法一旦调用结束，包装类型就会自动释放

为什么undefined和null不能使用.，他们俩没有提供过包装类型(没有任何属性和方法)

# Day031

## String API

### 转义字符：/

#### 何时使用

在字符串中出现和程序冲突的字符

1、比如:希望在""中再放入一个"，或"之中再放入一个'

```
"\""
```

2、具有特殊功能

\n 换行   \t制表符：就是敲Tab带来的大空格

3、可以书写unicode号代表一个字

\uxxxx
汉字的第一个字: lu4e00

汉字的最后—个字: lu9fa5

#### 英文转大小写

【统—的】将字符串转为大写或小写，再比较，忽略大小写(验证码)

```
大写: var upper=str.toUpperCase();
小写: var lower=str.toLowerCase();
```

#### 获取字符串中某个字符

```
str.charAt(i);           ==         str[i];
```

#### 获取字符串中某个字符的ascii码

```
str.charCodeAt(i);
```

#### 通过ascii码转回原文:

```
原文=String.fromCharCode(ascii);
```

验证码

![2](imgs\2.png)

#### 检索字符串

何时:判断有没有，不重复!

```
var i=str.indexOf("关键字" ,starti);
```

特殊

1、starti可以省略，如果省略默认从0位置开始向右查找

2、返回:如果找到了，返回关键字的第—个字符的下标

​	没找到返回-1，重点：我们其实根本不关心下标为几，我们只关心下标为不为-1，为-1说明没有，如果不为-1说明存在

3、数组也可以使用，其实以前数组是没有这个方法的，某次浏览器更新后，数组才可以使用的(老IE用不到)

4、【面试题】找到所有关键字的下标

```
var str="no zuo no die no can no bibi";
var index=-1;
while((index=str.indexOf("no",index+1))!=-1){
console.log("找到了，下标为: "+index);
)

```

#### 拼接字符串

```
var newStr=str.concat(str1 str2..)
```

#### 截取子字符串

```
1、var subStr=str.slice(starti,endi+1);
2、var subStr=str.substring(starti,endi+1);//几乎和slice一致，但是不如slice，因为不支持负数参数
3、 var subStr=str.substr(starti,n);
```

#### 替换字符串

```
var newStr=str.replace("固定关键字"/RegExp,"新内容");
```

#### 切割/分割字符串

功能：字符串< = > 数组

```
var arr=str.split("自定义切割符")
```

特殊

1、切割符是可以自定义的，切割后会返回一个数组，数组中不在包含切割符

2、如果传入的切割符""，每—个字符都会被切散

### 拓展：

#### input失去焦点事件

```
elem.onblur=function(){
}
```

#### JS创建页面元素并且渲染上DOM树

1、创建空标签

```
var xin元素=document.createElement("标签名");
```

2、为此标签设置必要的属性和事件

```
空标签.属性名="属性值"
```

3、把新元素上DOM树

```
父元素.appendChild(新元素)
```

# Day032

## 正则表达式

什么是:定义字符串中【字符出现规则】的表达式

### 何时使用

切割替换“验证”

### 如何使用

#### 最简单的正则

关健字原文，但是写法和以前的字符串不同,“no” ->  /no/ig

```
i:忽略大小写
g:全部，替换的话默认只会替换第一个匹配到的关键字
```

#### 备选字符集

—个备选字符集:规定一位字符可能出现的情况

何时使用：只要关键字有多种情况的时候

如何使用：/{备选字符集}/

强调：1、一个中括号，只能管一个字

​			2、问题：正则默认只要满足后，就不再管后续操作，后续用户就可以乱来!

​				解决：【只要是做验证】，我们肯定希望用户完全按照我们的规则来玩，必须写为:/^[备选字符集]$/·前加^后加$的意思是要求用户从头到尾完全匹配

特殊：

```
1、如果备选字符集种有部分unicode号是连续的，则可用-省略掉中间部分
比如：
	—位数字:[0-9]
	—位字母:[A-Za-z]
	—位数字、字母、下划线:[O-9A-Za-z ]
	—位汉字:[\u4e0O-\u9fa5];
2、除了xxx之外，其他都可以
	[^xxx]–范围太广，不推荐
```

#### 预定义字符集

前辈们提前定义了的一些常用的字符集

```
一个数字: \d   ===   [0-9]
位数字、字母、下划线: \w  ===
[0-9A-Za-z_]
一位空白字符:\s   ===
空格、制表符、换行
—位除了换行外的任意字符:. -范围太广，不推荐
```

问题:预定义字符集是固定的，不灵活

建议:开发时优先使用预定义字符集，预定义字符集满足不了，再用备选字符集补充

##### 强调：不管是备选字符集还是预定义字符集，一个都只管一位

#### 量词

规定了—个字符集出现的次数

##### 如何使用

1、有明确数量：

```
字符集{n,m}:前边相邻的字符集最少出现n次，最多出现m次
字符集{n,}:前边相邻的字符集最少出现n次，多了不限
字符集{n}:前边相邻的字符集必须出现n次
```

2、没有明确数量

```
字符集?:前边相邻的字符集，可有可无，最多一次
字符集*:前边相邻的字符集，可有可无，多了不限字符集
字符集+:前边相邻的字符集，至少—次，多了不限
```

#### 指定匹配位置

```
^:以xxxxx开头
$:以xxxxx结尾
*特殊:如果同时使用了，前加^后加$，从头到尾完全匹配-只要是做验证，必须这么写
```

#### 选择和分组

选择：可以再多个条件中选择一个

```
规则1|规则2
```

分组：选择和分组—般来说都是需要搭配使用的 - 添加子规则

```
(规则1|规则2)
```

7、目的:密码强度:4-6位密码，可以输入字母数字，但是必须要有一位大写和一位数字的组合

公式：比如

```
    1、/^(?![0-9]+$)$/ -不能全由数字组成，可能有大写字母、小写字母、汉字、特殊符号、日文、韩文...
2、/^(?![A-Zd-z]+$)$/–不能全由大写组成，也不能全由小写组成，也不能由大写和小写的组合组成，可能有数字
```



## 字符串支持正则的API

### 切割

```
str.split("固定切割符/正则表达式")
```

### 替换

#### 基础替换法

```
str=str.replace(/正则表达式/gi,"新内容");
注意：替换时，不要前加^后加$，我们不需要完全匹配，只需要找到关键字做替换而已，想要替换所有的一定要加后缀g
```

问题：替换的新东西，只能是一个固定的

#### 高级替换法

```
str=str.replace(/[我卧握窝][去槽操曹草]+/g,function(key,i,str)//此回调函数会自动调用，找到几个关键字就会执行几次
console.log(key);//当前次正则匹配到的关键字
console.log(i)://当前次正则匹配到的关键字的下标console.log(str);//原文本身
return key.length==2?"**"."***":
});
```

#### 格式化

如果替换时，正则中，带有分组，那么你的回调函数会得到更多的形参

```
var str="500103198602215933";
var reg=/d{6}(/d{4})(/d{2})(/d{2})d{4}/;
str=str.replace(reg,function(key,a,b,c,....,i,str){
console.log(key);//正则匹配到的内容
console.log(a);//第一个分组匹配到的内容
console.log(b);//第二个分组匹配到的内容
console.log(c)://第三个分组匹配到的内容/ /...
你有多少个分组就会多出多少个形参，但是最后两个—定是下标和原文
console.log(i);
console.log(str);
return a+"年"+b+"月"+c+"日";
console.log(str);

```

## 正则对象

### 创建：

1、直接量方式：

```
var reg=/正则表达式/后缀;
```

2、构造函数方式: var reg=new RegExp("正则表达式"，"后缀");

### 方法：

```
var bool = reg.test(user)
根据布尔值去做出正确的提示文字和样式，以及错误的提示文字和样式
```

# Day033

## Math

专门用于提供数学计算的API

强调：不能、不需要创建，浏览器自带

属性：Math.API

### API

#### 取整：3种

```
上取整:只要超过，就会取下一个整数
	Math.ceil(num); -小数位数不能超过15位，超过后会失效

卜取整:无论超过多少，都省略小数部分
	Math.floor(num);

四舍五入取整
	Math.round(num)
```

以上三个都是垃圾:只能取整,而且不能指定保留小数位数：个人推荐num.toFixed(d)；//d可以设置指定保留小数位数，而且也具有四舍五入的功能，唯一缺陷：返回的是个字符串。建议搭配parseInt()使用

【面试题】：自定义一个函数，按照人员小数位数四舍五入，返回数字类型，不允许使用tofixed

```
function dy(num,d){
	num*=Math.pow(10,d);
	num=Math.round(num);
	num/=Math.pow(10,d);
	return num;
}
var result=dy(Math.PI,3);
console.log(result)
```



#### 乘方和开方

```
乘方：Math.pow(底数,幂)；
开放：Math.sqrt(num)   -只能开2次方
```

#### 最大值或最小值

var max/min=Math.max/min(num1,num2,....)

可以获取出传入的参数中最大/小的值

问题:不支持传入数组参数，比较数组的最大值和最小值解决: Math.max/min.apply(Math,arr);
其实apply可以悄悄的打散数组，将每个元素单独传入-ES5带来的一个新特性其实apply可以借用方法
笔试题:比较出数组中最人值/最小值（2个方法)

#### 绝对值

将负数变成正数

```
Math.abs(num);
```

#### 随机数

```
Math.rondom():在0-1之间取随机数
		可能取到0，但是不可能取到1  -可能取到最小数,但是不可能取到最大数
在min~max之间取随机整数的公式
parseInt(Math.random()*(max-min+1)+min;)
如果你的最小值是0
parselnt(Math.random()*(max+1));
```

## Date

封装了一个事件对象，提供了对时间进行操作的API的对象

### 何时使用

只要计算时间，就要用到Date

### 如何使用

#### 1、创建

##### 1、创建一个日期对象，获取客户端当前时间

```
var now =new Date();
```

##### 2、创建一个自定义时间

```
var birth = new Date("yyyy/MM/dd hh:mm:ss")
```

##### 3、创建一个自定义时间(另一种):

```
var birth=new Date(yyyy,MM-1,dd,hh,mm,ss);
```

取值范围: MM: 0~11月份需要修正

##### 4、复制—个日期对象

为什么:日期对象的API都是直接修改原日期对象的，无法获得修改之前的日期
何时使用:如果你希望同事获得修改前和修改后的两个日期，则应该先复制一份，然后再去修改其中一份

```
var end =new Date(start);
```

### 2、使用

1、拿着两个日期对象可以相减，你会得到一个毫秒差，通过毫秒差换算你想要的任何一部分

#### API操作

2、API操作：分量：时间单位

```
年月日星期:FullYear Month Date Day
时分秒毫秒: Hours Minutes Seconds Milliseconds
```

##### 1、每个分量都有一对getXX /setXX

特殊：Day：没有set方法

2、取值范围：

```
FullYear:就是当前年份的数字
Month: 0~11，计算机中的月份比现实-1
Date: 1~31
Day: 0~6:0代表星期天，外国人的眼里，星期天是一个星期的第一天
Hours:0~23
Minutes、Seconds: 0~59
```

3、日期看上去像一个字符串—样黑色的，但是日期对象和字符串能用的API不同，而且日期对象很聪明，会自动进制

建议：对一个日期的某个分量做计算

```
date.setXXX(date.getXXX()-/+n)
```

### 3、日期格式化

```
date.toLocaleString();
/会转为一个本地日期格式的字符串，虽然不能自动进制，也不能用日期的API，但是可以用字符串的API了
```

垃圾:具有兼容性问题，老E输出的和主流浏览器输出的东西不—样

解决:自定义format函数

# Day034

## Error对象:错误对象

### 1、浏览器自带4种错误类型–帮助你们快速找到错误

```
SyntaxError -语法错误:一定是符号/语法写错
ReferenceError -引用错误:没有创建的东西，你就去使用了
TypeError -类型错误:使用了不是自己的属性和方法
RangeError -范围错误:只有一个API会遇到,num.toFixed(d):
//d必须在0~100之间
```

### 2、错误处理:当程序发生错误时，保证程序不会异常中断的机制

为什么:程序默认只要碰到错误就会停止/闪退，用户体验感差如何错误处理:
try{
可能发生错误的代码
}catch(err){
发生错误时才会执行，err形参会自动得到错误的信息，英文的建议你自己在加上中文错误描述
)
性能垃圾:放在try中的代码，效率都会被降到最低
解决:完全可以用if...else代替 try...catch，所有的一场都可以提前预判
需要经验的累积:一切客户端都是坏人，都要防他一手:

1、if...else.. 2、!isNaN 3、【正则验证】

### 3、抛出自定义错误/异常:

throw new Error("自定义文字");

## Function对象:【考点】

提前创建好，以后可以反复使用的代码段

js中的函数也是一个对象，函数名其实是引用函数对象的变量

### 创建：3种

#### 声明方式：

```
function函数名(形参列表)(函数体;return返回值;} -完整的声明提前
```

#### 直接量方式：

```
var函数名=function(形参列表){函数体;return返回值;} –完整的声明提前
	拓展：
		d1.onclick=function(){}
```

#### 构造函数方式：

```
var函数名=new Function("形参",...,"函数体;return 返回值;");
	
强调:无论参数实际是什么类型，创建函数时的每一部分都必须用""包裹
```

##### 何时使用

如果函数体不是固定的，而是字符串动态拼接的

### 作用域

### 声明提前

### 按值传递

### 重载(overload)

相同函数名，不同参数列表的多个函数

为什么：减轻程序员的负担！

#### 问题

JS的语法不支持重载!JS不允许同时存在多个同名函数，如果同时存在，最后一个的函数会覆盖掉之前所有的

#### 解决

在函数内部有—个对象: arguments

什么是arguments对象:函数中，自带的，不需要我们创建的，是一个类数组对象，作用:接受住所有的实参

##### 类数组对象

只有3个点是和数组相同

```
1、都可以用下标访问某个元索
arguments[i]-传入的某个实参
2、都可以用length获取到长度
arguments.length
3、可以遍历拿到每一个元素– for循环
强调:类数组对象不是数组，所有的数组的APl，类数组都不能使用
```

###### 何时使用：

```
1、以后不需要形参，也可以接住所有的实参!
2、变相实现重载:在函数内部判断传入的实参的不同，执行不同的分支操作
```

### 匿名函数

创建的函数，没有函数名引用着

#### 何时使用：

如果函数，只会执行一次

为什么:节约内存，匿名函数没有变量引用着，用完，就会自动释放

##### 匿名函数自调

只会执行一次，执行完毕后会自动释放，代替全局写法，节约内存空间

```
(function(){
	console.log("我是匿名自调");
})();
```

##### 匿名函数回调

将函数调用时，传入的实参，又是一个匿名函数，不需要我们程序员调用，会由主函数自动执行

确实是前辈们，怎么规定，我们怎么使用，但是我们了解到，原来这个回调函数不是没有调用，只不过是前辈们提前帮我们调用好了

```
function A(B){
	B();
	console.log("我是主函数" );
}
A(function(){
	console.log("我是副函数");
})
```

```
arr.sort(function(a,b){return a-b;})
str.replace(reg,function(){})
btn.onclick=function(){} -就算你听懂了怎么简化为箭头函数，也暂时不要在事件上写箭头函数
```



## 闭包

### 作用域(scope)

#### 全局作用域

成员:随处可用，可以反复使用，缺陷:容易被污染

#### 函数作用域

成员:不会被污染，只有函数调用时内部可用，缺点:调用结束后，就释放了，一次性的，不可反复使用

### 函数的执行原理

#### 1、程序加载时

​	创建执行环境栈(ECS):保存函数调用顺序的数组

​	首先压入全局执行环境(全局EC),全局EC中引用着全局对象window，window中保存着全局变量

#### 2、定义时

创建函数对象:封装代码段

在函数对象中定义了scope属性，记录着函数来自的作用域，全局函数的scope都是window

#### 3、调用前

在执行环境栈中压入新的函数的EC
创建出活动对象(AO):保存本次函数调用用到的局部变量在EC中添加了scope chain(作用域链)属性引用着AO设置AO的parent属性为函数的scope引用的对象

#### 4、调用时

变量的使用规则:优先使用局部变量，局部没有找全局，全局没有就报错

#### 5、调用完

函数的EC会出栈，AO自动释放，局部变量也就自动释放

### 两链一包

#### 作用域链(scope chain):

以函数的EC中的scope chain属性为起点，经过AO，逐级引用，形成的一条链式结构

##### 作用：

查找，带来了变量的使用规则:优先使用局部变量，局部没有找全局，全局没有就报错

### 闭包：

保护—个可以【反复使用的局部变量】的一种词法结构

#### 为什么

全局变量: 缺:容易被污染

局部变量: 缺:—次性

#### 如何使用

1、两个函数进行嵌套
2、外层函数创建受保护的局部变量，并且返回内层函数

3、内层函数在操作受保护的局部变量

简单的例子

```
function outer(){
	var i=0;
	return function(){
		i++;
		return i;
	}
}
```

#### 强调

1、判断闭包，有没有两个函数在嵌套，并且外层函数创建了变量,return了内层函数

2、外层函数调用几次，就创建了几个闭包，受保护的变量就有了几个副本

3、同一次外层函数调用，返回的内层函数，都是使用同一个受保护的变量

缺点：唯一的缺点：受保护的变量永远不会被释放，过度使用闭包，会导致内存泄漏

#### 使用场景：

防抖节流 -3个事件会非常影响性能

##### 防抖节流公式：

```
function fdjl(){
	var timer;//受保护的变量
	return function({
	/操作受保护的变量
	if(timer){clearTimeout(timer)}
		timer=setTimeout(function(){
		//考虑你要做的操作是什么
		},1000)
	}
}
var inner=fdjl();
//inner()内层函数才是写在事件中的操作
```

​	

```
1、elem.onmousemove-鼠标移动就会触发，触发次数很多很快，但是不要让他疯狂的渲染DOM

2、window.onresize
-窗口的尺寸只要发生变化就会触发，

```

## Object

面向对象开发方式:

三大特点:封装、继承、多态

### 【面试题】:简单的说一下你了解的面向过程和面向对象开发方式的区别?

面向过程:开始->经过->结束，我们从开始到现在学习写法的一直都是面向过程
面向对象:对象（属性和方法)，如果这个世界有各种属性和各种方法，但是连一个对象/生物都没有，那这些东西就没有具体的意义,我们把所有的代码全部包含在一个对象中来进行描写，才更符合现实生活

之前用的11个引用类型对象，都是浏览器的js解释器提供的，我们直接学习如何使用，但是我们现在可以学习如果创建属于自己的对象(可惜前辈们没有提供过轮播、选项卡、购物车)

### 学习如何创建自定义对象:

#### 1、封装/定义/创建对象:3种

#### 1、直接量方式:

```
var obj={
	"属性名":属性值,
	"方法名":function(形参){函数体},
	…
);

强调:
1、属性名和方法名的引号其实是可以省略的，但是不建议，因为以后我们会学习一种数据格式叫做JSON.要求属性名和方法名的【双引号】不能省略
2、如何访问对象的属性和方法
		对象名.属性名			===		对象名["属性名"] 
		对象名.方法名();		===		对象名["方法名"]()
js中万物皆对象，除了undefined和null，一切对象的底层都是哈希数组

特殊：1、访问到不存在的属性，返回undefined
	 2、随时随地可以添加不存在的属性和方法
	 3、希望获取到对象之中所有的东西：遍历对象：for in循环
	 	for(var i in obj){
			console.log(obj[i]);
		}
	 4、如果你希望在对象的方法内部使用对象自己的属性，我们需要写为this.属性名;
		this指向
		1、单个元素绑定事件this->这个元素
		2、多个元素绑定事件this->当前元素
		3、函数中this->谁在调用此函数this指向谁
		4、定时器中this->window  
		5、箭头函数this->外部对象
```

### 2、构造函数方式：垃圾

```
var obj=new object(); 
obj.属性名=属性值;
obj.方法名=function()
//obj.name="袍哥";
//obj.age=18;
//obj.salary=200000;
```

以上两种创建方式有一个缺点：仅仅适合创建单个对象，如果创建多个对象，代码冗余太高

### 3、专门创建多个对象准备的

#### 自定义构造函数方式：2步

```
1、创建构造函数
function类名(name,age,hobby){
	this.name=name;
	this.age=age;
	this.salary=salary;
}
2、调用自定义构造函数创建出对象
var obj=new类名(实参…);
```

面向对象开发方式的好处: 

​	1、不适合初学者，逼格高！

​	2、特地把每一块功能分开写 - 哪怕不需要注释，也便于维护！

​	3、铁索连舟 -更符合现实生活

​	4、所有东西都包含在一个对象之中- 更符合现实生活

![3](imgs\3.png)

##  Object面向对象

### 继承

父对象的成员(属性和方法)，子对象可以直接使用

#### 作用

代码重用!节约内存空间

#### 何时继承

只要多个子对象公用的属性和【方法】，都要集中定义在父对象之中

### JS的面向对象是基于原型(爸爸)的

#### 什么是原型

保存—类子对象共有属性和共有【方法】的父对象（原型对象)，每个对象天生就有—个原型

#### 1、获取原型对象：2种

```
1、对象名.__proto__;
-必须先创建出一个对象，才可以使用此方法

2、构造函数名.prototype;
-构造函数名: Array、function、Date、
–哪怕没有创建过任何对象也能找到原型
```

#### 2、两链一包

##### 作用域链：

以函数EC的scope chain属性为起点，经过AO逐级引用，形成的一条抛式结构，作用:查找变量的，带来了变量的使用规则:优先使用自己的，自己没有找全局，全局没有则错

##### 闭包：

保护了—个可以反复使用的局部变量的词法解构

##### 原型链：

每个对象都有一个. _proto_的属性，可以不断的连续,找到爸爸-爷爷-祖祖...形成的一条链式结构

最顶层：Object.prototype是对象的原型，所有也就有了一句话:万物皆对象

作用：查找属性和方法，自己没有的属性和方法，可以顺着原型链进行查找，所以人人都可以使用toString()

#### 3、获取到原型对象则可以设置共有属性和共有方法

​	原型对象.属性名=属性值;//共有属性

​	原型对象.方法名=function00://共有方法

![4](imgs\4.png)

自有和共有

​	自有:保存在对象本地的属性
​	共有:保存在父(原型)对象的属性，所有的子对象都可以使用

### 【笔试题】

#### 1、如何判断自有和共有

```
判断自有:obj.hasOwnProperty("属性名");
返回一个布尔值: true说明是自有，false可能是共有也可能是没有
```

```
判断共有:2个条件:
1、不是自有:obj.hasOwnProperty("属性名")==false;
2、自动在原型链检查:"属性名" in 对象名;
if(obj.hasOwnProperty("属性名")==false&&"属性名" in 对象名){
//共有
)
}
```

完整版：

```
if(obj.hasOwnProperty("属性名"))(
console.log("自有");
}else{
if("属性名" in对象名)(
console.log("共有")
}else{
console.log("没有)
}
)
```

#### 2、修改或删除属性

##### 1、修改和删除自由属性

```
修改: obj.属性名=新值;

删除: delete obj.属性名;
```

##### 2、修改和删除共有属性

```
修改:原型对象.属性名=新值;

删除: delete 原型对象.属性名;
```

##### 3、为老IE的数组添加indexOf方法

![5](imgs\5.png)

```
if(Array.prototype.indexOf===undefined){ //我不希望主流浏览器也执行到这些代码，我只希望老工E执行到
	Array.prototype.indexOf=function(key ,starti){//indexOf的执行原理
	starti===undefined&&(starti=0); //说明用户没有传入开始位置，我们就给用户设置为从下标8开始查找
	for(var i=starti;icthis.length;it+){//从开始位置处，征环数组后面的每一个文字和用户输入的关键字进行匹配
	if(this[i]==key )i
  	return i; //匹配到了返回对应的下标
}
//没匹配到,返回-1 return -1;
```

```
//为字符串添加一个去掉开头空白,和结尾空白的方法String.prototype.dls=function(){
	return this.replace( /^\s+|\S+$/g,"");
}
```

#### 4、判断一个对象是不是数组？4种方法

##### 1、判断x是不是继承自Array.prototype

```
Array.prototype.isPrototypeOf(x);
如果返回true，说明是数组，否则不是数组
```

##### 2、判断x是否是由构造函数Array创建的

```
x instanceof Array
```

##### 3、ES5提供了一个API:Array.isArray(x);

-此方法不是人人都有，而且ES5以上的东西，老IE都不支持

##### 4、输出对象的字符串形式:

​	在Object的prototype原型上放着最原始的toString 原始的toString，默认输出[object构造函数名]

#### 多态(override)/重写:

子对象绝对父对象的成员不好用，可以在本地定义同名成员，覆盖父对象之中的成员

我希望借用到函数:跳过爸爸，直接去找爷爷拿

```
Object.prototype.toString.apply(x)==="[object Array]";
```

#### 5、实现自定义继承

##### 1、实现两个对象之间的继承

```
子对象.__proto__=父对象;
```

##### 2、直接匹配设置继承

```
构造函数名.prototype=父对象;

时机:先设置好父对象，再创建子对象
```

## ES5&&ES6

### 1、保护对象:保护对象的属性和方法

#### 1、四人特性:每个属性都有四大特性

```
"value": 3500,/ /实际保存属性值的地方
"writable" : true,//开关:控制着是否可以被修改
"enumerable": true,//开关:控制着是否可以被for in循环遍历到
"configurable" : true//开关:控制着是否可以被删除
```

修改四大特性:

```
Object.defineProperties(obj,{
"属性名":{四大特性}
})
```

#### 2、三个级别

##### 1、防扩展:禁止给对象添加任何新属性

```
Object.preventExtensions(obj);
```

##### 2、密封:禁止给对象添加任何新属性，也不能删除属性

```
Object.seal(obj);
```

##### 3、冻结:禁止给对象添加任何新属性，也不能删除属性，也不能修改属性

```
Object.freeze(obj);
```

不重要的原因:
1、如果你不用面向对象，你保护个屁

2、前辈们都没有保护，你保护个屁

### 2、数组新的API：3组6个

#### 1、判断：判断数组中的元素是否符合要求

​		every	-每一个：判断数组中的每个元素【都】要符合要求最后结果才为true，类似于&&，只要有一个不满足，结果为false

​	语法：

```
arr.every(function(val,i,arr){
console.log(val);//当前元素
console.log(i);//当前元素的下标
console.log(arr);//数组本身
return判断条件;
)) 
```

​		some	-有一些：判断数组中的是否包含符合要求的元素，只要有一个最后结果则为true,类似||，只要有一个满足，则为true

```
arr.some(function(val,i,arr){
console.log(val);//当前元素
console.log(i);//当前元素的下标
console.log(arr);//数组本身
return判断条件;
)) 
```



#### 2、遍历：对每个元素执行相同 或 相似的操作

##### forEach：直接修改原数组

```
arr.forEach(function(val,i,arr){
	操作;//直接修改val的值并没有用，要修改arr[i]
)) 

```

##### map:不修改原数组，返回新数组

```
var newArr=arr.map(function(val,i,arr){
	return 操作;
})
```

#### 3、过滤和汇总

##### 过滤：筛选出原数组之中符合条件的元素组成—个新数组!原数组不变！

```
var newArr=arr.filter(function(val,i,arr){
	return 判断条件;
})
```

##### 汇总：将数组中每一个元素，取出来整合为一个最终结果

```
var sum=arr.reduce(function(prev,val,i,arr){
console.log(prev);//当前元素的前一个元素
console.log(val);//当前元素
	return prev+val
},基础值)
```

以上6个API其实都是简化了同一件事，for循环，意味着以后呆老师可能不会再写for循环

### 3、Object.create()方法:(垃圾)

直接用父对象创建子对象，并且子对象扩展自有属性

语法：

```
var 子对象=Object.create(父对象{
		"自有属性名":{四大特性}
})
```

### 4、严格模式：很严格

​	如何开启："use strict",可以放在任何一个作用域的顶部

1、禁止给未声明的变量赋值–-解决了全局污染

2、将静大败升级为了错误

### 5、call、apply、bind

#### 1、call、apply临时替换函数中的this，借用

语法：

```
要借用的函数.call/apply(借用的对象,实参1,....);

要借用的函数apply(借用的对象,arr); - apply除了有借用的功能，还会悄悄的打散我们的数组
```

区别：

call,要求传入函数的实参必须单独参入
apply, 要求传入函数的实参必须是一 个数组

#### 2、bind：【永久替换函数中的this】

语法：

```
var 新函数=老函数.bind(指定的对象)
```

3件事：

1、创建了一个和原函数功能完全一 样的新函数
2、将新函数中的this永久绑定为你指定的对象
3、将新函数中的部分参数永久固定

强调: bind绑定在新函数中的this,无法被call、 apply再次替换借走

#### 总结：

如果临时调用一个函数，立即执行 -- call/apply

如果创建一个函数提前绑定this,不一定希望立刻执行- bind

使用场景:
1、比较出数组中的最大值和最小值: 

```
Math.max/min.apply(Math,arr)
```

2、得到Object最原始的toString: 

```
Object.prototype.toString.call/apply(arr);
```

3、将类数组对象转为普通数组: 

```
var 新数组=Array.prototype.slice.call/apply(类数组对象)
```

其实ES5还提供了一个数组API,可以直接将类数组对象转为普通数组:

```
 var 新数组= Array.from(类数组对象)
```

![6](imgs\6.png)

### ES6新语法

#### 1、模板字符串

简化字符串拼接，支持在模板字符串之中书写变量

语法：

```
语法:`我的名字叫${name}`
在字符串中实现了一个简单的js环境
```

#### 2、let关键字

创建变量以后优先使用let，再考虑var

let变量名=值;
优点:
1、解决了声明提前
2、添加了块级作用域，一个{}就是一 个块
3.如果绑定事件时，用到了let来遍历，那么let会记录住你当前元素的下标-你以后再也不需要自定义下标了

#### 3、箭头函数

简化一切的回调函数

```
去掉function，()和{}}之间添加=>，形参只有一一个可以省略())
函数体只有一句话，省略{}
函数体只有一句话，并且是return,省略{}和return
```



#### 4、for..of:垃圾

```
for(var v of arr){
		v - 直接拿到值
}
```

1、无法修改原数组

2、不能遍历hash数组，也不能遍历对象

#### 5、解构赋值

#### 6、Set和Map类型

#### 7、模块化开发

#### 8、Promise

#### 9、Class



## DOM

什么是DOM: Document Object Model (文档对象模型)
将每一个标签/属性/文本/注释/元素，都看作是一个DOM元素/节点/对象(提供了一些操作元素的属性/方法)

### 面试题:

HTML/XHTML/DHTML/XML分别是什么?

1、HTML -网页
2、XHTML-更严格的HTML，HTML5->XHTML->HTML4.01
3、DHTML -动态的网页:D: Dynamic -其实并不是新技术、新概念，是将现有技术的整合统称，让我们在离线时，网页也具有动态效果
DHTML: html+css+js (dom)
4、XML–未知的标记语言，一切的标记由自己定义数据格式

### DOM的组成：

原本是可以操作一切结构化文档的FHTML和XML，后来为了方便各类开发者分为了3部分

1、核心DOM：【无敌，既可以操作HTML，又可以操作XML】缺陷:API比较繁琐
2、HTML DOM 只能操作HTML，API简单，缺陷:比如属性部分，只能访问标准属性，不能访问自定义属性
3、XML DOM 只能操作XML，XML已经淘汰了

-现在最流行的数据格式是JSON

## DOM树

树根: document -不需要我们创建，一个页面只有一个document对象，由浏览器的js解释器自动创建

### 作用

可以通过树根找到页面上的每一个DOM元素/节点/对象，也可以操作它

### 每个DOM元素都有三大属性

#### 1、elem.nodeType:描述节点的类型

document节点:9

element节点:1

attribute节点:2

text节点:3

以前有用:判断xx是不是一个页面元素-因为我教你们方法children，是不会得到文本节点的，但是以前的childNodes会得到文本节点

#### 2、elem.nodeValue:描述节点的值

以前有用:先拿到属性节点，再用此属性去获取属性值

#### 3、***elem.nodeName:描述节点的名字

拿到当前元素的标签名。判断xx是什么标签

注意：返回是一个全大写组成的标签

#### 4、通过关系获取元素

父: xx.parentNode
子: xx.children -集合:只能找到儿子

第一个儿子: xx.firstElementChild

最后一个儿子: xx.lastElementChild

前一个兄弟:xx.previousElementSling

后一个兄弟: xx.nextElementSibling

#### 5、***递归：简单来说就是函数中，又一次调用了函数自己，迟早有一天会停下来

##### 何时使用:

遍历DOM树，专门用于【遍历层级不明确】的情况，既可以遍历层级不明确的DOM树，也可以遍历层级不明确的数据

如何使用：2步

```
function函数名(root){
	1、第一层要做什么直接做!
	2、判断他有没有下一级，如果有下一级，再次调用此函数，但是传入的实参

}
函数名(实际的根)
```

算法：深度优先！优先遍历当前root的子节点，子节点遍历完才会跳到兄弟节点

递归的缺点：同时开启大量的函数调用，大量消耗内存，只有一个情况才用：【遍历层级不明确】

递归vs循环:
递归:优点:直观、易用
缺点:性能较低，尽量只在层级不明确的时候使用循环:优点:几乎不占用内存
缺点:难得批爆

#### 6、TreeWalker

专门提供了一个遍历层级不明确的DOM树的API

##### 步骤

```
1、先创建出tw :
document.createTreeWalker(根元素,NodeFilter.SHOW_ALL/SHOW_ELEMENT);
2、tw对象过后，你会得到一个方法
while((node=tw.nextNode())!=null){}
	node.style.border="1px solid #000";
}
```

缺陷:
1、自动的跳过根元素，根元素是不会做任何操作的
2、仅仅只能遍历层级不明确的DOM树，不能遍历层级不明确的数据

#### 7、API直接找元素

##### 1、根据HTML的特点去找元素

```
ID: var elem=document.getElementByld("id值");
标签名和class和name: var elems=document.getElementsByTagName/ClassName/Name("标签名/class名");
```

##### 2、*根据CSS选择器去找元素

```
1、单个元素
var elem=document.querySelector("任意的css选择器");
强调:万一选择器匹配到多个，只会返回第一个
	没找到null

2、**多个元素
var elem=document.querySelectorAll("任意的css选择器");
强调:找到了返回集合，没找到返回空集合
	更适合做复杂查找
```

###### 【面试题】getXXX和querySelectorAll有什么区别？

返回的结果不同：

1、getXXX:返回的是要给动态集合HTMLCollection

​		优点：数据始终和DOM树实时挂钩

​		缺点:每次DOM树进行修改，都会悄悄的再次查找元素，效率相对较低

2、 querySelectorAll:返回的是要给静态集合NodeList

​		优点:每次不会悄悄重新查找，效率较高，而且还支持使用forEach!

​		



## 操作元素

<标签属性名="属性值" style="样式">内容</标签>

强调:页面上获取/设置到的一切数据都是字符串类型

### 1、元素的内容

#### 1、elem.innerHTML：

获取或设置开始标签到结束标签之间的HTML代码，没有兼容性问题的，可以识别标签

```
获取: elem.innerHTML
设置:elem.innerHTML="新内容"
```

#### 2、elem.textContent:

获取或设置开始标签到结束标签之间的纯文本，有兼容性问题的(老IE不支持)，不能识别标签

```
获取: elem.textContent
设置: elem.textContent="新内容”
```

老IE: elem.innerText-我们第一次见到小三上位，innerText某次浏览器更新后，现在主流浏览器也支持此属性

为什么老IE不将就主流?-微软的，生活中，PC端只有windows系统和MAC系统（土豪)，windows系统的使用的人多

#### 3、*input.value:

获取或设置表单控件的值

```
获取:input.value
设置: input.value="新值"
```

### 2、元素的属性

#### 1、获取属性值

```
核心DOM: elem.getAttribute("属性名");
HTML DOM: elem.属性名;
```

#### 2、设置属性值

```
核心DOM: elem.setAttribute("属性名":"属性值");
HTML DOM: elem.属性名;
```

#### HTML DOM缺陷:

1、class需要写为className

2、不能操作自定义属性
开发中:优先使用HTML DOM，HTML DOM满足不了再用核心DOM补充

#### 3、删除属性值

```
核心DOM: elem.removeAttribute("属性名");
HTML DOM: elem.属性名="" -删除不推荐使用HTML DOM，删除不干净属性节点，而有的属性，光有属性名就已经具有功能了
```

#### 4、判断有没有属性 -垃圾

```
核心DOM: elem.hasAttribute("属性名")-仅仅只能判断有没有这个属性，不能判断出属性值是什么
HTML DOM:elem.属性名!=""
```

### 3、元素的样式

#### 1、*内联样式：优先级最高，一定会覆盖其他的样式

仅仅当前元素可用，不会牵一发动全身

```
获取样式: elem.style.css属性名;
设置样式: elem.style.css属性名="css属性值";
```

唯一的缺陷:获取样式时，只能获取到内联样式

#### 2、样式表中的样式–学了你也懒得用

//1、找到你想要操作的样式表
var sheet=document .stylesheets[i];

/ /2、获取样式表中所有的样式规则
var rules=sheet.cssRules;

//3、找到自己想要操作的样式规则

var rule=rules[i];
//4、要么获取要么设置

rule.style.background="purple";

#### 拓展

html5和ES5以上得一切东西老IE都不支持，但是也不要怕，其实以后做兼容的情况很少

趋势:手机端
PC就算要做也只做到lE8

## 1、创建元素并且渲染DOM树:3步

### 1、创建空标签:

```
var elem=document.createElement("标签名");
```

### 2、添加必要的属性和事件

```
elem.属性名="属性值";
elem.on事件名=function(){操作}
```

### 3、上树:将js内存中的新标签放到DOM树上

```
父元素.appendChild(elem) -将elem追加到父元素里当最后一个儿子

父元素.insertBefore(elem,已有子元素)-将elem追加到父元素里，但是会插入在已有子元素的前面

父元素.replaceChild(elem,已有子元素)-将elem追加到父元素里，但是会替换在已有子元素的
```

2、删除元素:

```
 elem.remove();
```

## HTML DOM常用对象:简化【核心DOM)

### 1、image对象：

仅仅只是简化创建步骤

```
创建: var img=new lmage() === var elem=document.createElement("img");
```

注意：不是都有构造函数创建方式

### 2、form对象：

简化了查找元素

```
查找form元素: var form=document.forms[i]

查找form元素中的表单控件: var inp=form.elements[i];

*专属事件: form.onsubmit=function()//提交事件:只会再提交的一瞬间执行
return false;//阻止提交
}
```

### 3、*select对象：

#### 属性

1、select.options;//得到select下面所有的option，完全等效于xx.children;

2、select.selectedIndex;//得到当前选中项的下标，当时做二级（多级）联动就用到了他

#### 方法

1、*select.add(option);//完全等效于appendChild

2、select.remove(i);//删除下标为i的option

#### 专属事件

```
select.onchange=function()//只有选中项发生变化了才会触发}
```

### 4、*option对象:仅仅只是简化了创建语句，但是非常牛逼

#### 创建: 

```
var opt=new Option(innerHTML,value);
```

一句话完成四个操作：

```
select.add(new Option("innerHTML","value"))
```

# Day41

## BOM

Browser Object Model:浏览器对象模型:提供专门用操作浏览器的一些对象（属性和方法)，没有标准 -使用率相对较低，重点：定时器，事件对象event

DOM:

是有标准的:w3c规定的，几乎没有兼容性问题

## window对象

扮演着两个角色

1、代替了ES中的global，充当全局对象–保存全局变量和全局函数

2、自己也带有一些属性和方法，指代当前窗口本身



### 1、网页打开新链接的方式:4种

#### 1、替换当前页面，可以后退

```
HTML: <a href="url">内容</a>
Js: open("url"," _self");
```

#### 2、替换当前页面，禁止后退

-场景:电商网站，付款后不允许退回去再次付款

```
history对象:记录着【当前窗口】的历史记录，只有有了历史才能前进后退
location对象:记录着【当前窗口】正在打开的url，而他又一个方法叫做替换，替换是不会产生任何历史记录的，但是url替换后网页必然跳转
JS: location.replace("新url")
```

#### 3、新窗口打开，可以打开多个

```
HTML: <a href="url" target="_blank">内容</a>
Js: open("url"," _blank");
```

#### 4、新窗口打开，只能打开一个

-场景:电商网站，只允许用户打开一个付款页面

```
HTML: <a href="url" target="自定义name">内容</a>
自定义name的意思:每一个窗口底层都有一个名字，target其实就是在设置名字，name如果相同，新打开的窗口就会把旧窗口给替换掉JS: open("url","自定义的name");
```



#### 拓展a标签的作用：

1、跳转

2、锚点

3、下载

```
<a href="xx.exe/zip/7z">内容</a>
```

4、打开

```
<a href="xx.图片后缀">内容</a>
```

5、直接书写js

```
<a href="javascript:js代码;">内容</a>
```

### 2、window提供了属性和方法:

#### 属性

获取浏览器的完整大小: 

```
window.outerWidth/outerHeight;
```

获取浏览器的文档显示区域的大小: 

```
window.innerWidth/innerHeight
```

获取屏幕的完整大小: 

```
window.screen.width/height;
```

每个人的电脑分辨率是不一样的

#### 方法：

##### 1、打开窗口: 

```
var newWindow=open("url""自定义的name" "width=,height=,left=,top=");
```

注意:

1、第三个配置参数没有传入时，窗口大小和浏览器一样，并且黏在浏览器上面(融为一体)

2、写入了第三个实参，则会脱离浏览器并且一个独立的小窗口，并且可以保存起来，设置为他绑定事件

3、宽高不能设置的太小了

##### 2、关闭窗口：

```
window/newW.close();
```

##### 3、修改窗口的大小: 

```
newW.resizeTo(new宽,new高);
```

##### 4、修改窗口的位置:

```
newW.moveTo(x,y)
```

##### 拓展：获取鼠标的位置

1、绑定事件:事件处理函数形参可以写一个e，自动获取到事件对象event-明日的重点

2、获取坐标:3种
e.screenxY -获取鼠标相对于屏幕的位置

e.clientX/Y -获取客户端/浏览器的位置

e.pagex/Y-获取鼠标相对于页面的坐标

鼠标的跟随动画:事件

1、window/document.onmousemove

2、js的加载速度比图片的加载速度快，加载事件: onload事件

3、删除图片，实在动画开始时开启了定时器

定时器:
1、周期性定时器

```
开启: timer=setlnterval(callback,间隔毫秒数);
停止: clearlnterval(timer)
```

2、一次性定时器

```
开启: timer=setTimeout(callback,间隔毫秒数);
停止: clearTimeout(timer)
```

注意:一次性和周星期底层都是一样的，甚至可以呼唤，所以你到底以后用哪个无所谓

#### 【面试题】函数和循环和定时器都能反复执行操作，区别？

时机不同

1、函数–用户触发、程序员调用

2、循环-—瞬间基本就结束了

3、定时器-等待一段时间做一次

# Day042

## BOM的其他对象

### 1、history对象:

保存【当前窗口】的历史记录(打开【过】的url) ，可用于

```
前进：history.go(1);
后退：history.go(-1);
刷新：history.go(0);
```

### 2、navigator对象

保存了当前浏览器的基本信息，可以使用js来判断我们是什么浏览器以及版本号   - 类似于css  hack(浏览器兼容性问题的，专门针对老IE)

属性：

```
navigator.userAgent; - 能够得到一个字符串，包含着是什么浏览器以及版本号
```

### 3、location对象

#### 1、*常识:

一个url网址由哪些部分组成–5部分

协议名:https、http、ftp.ws(直播)....
域名/主机号:底层大家都是主机号，域名是需要花钱购买的
端口号:默认端口可以省略不写，https默认端口为443，http默认端口为80

文件的相对路径/路由:百度把他加密了隐藏起来了

查询字符串/请求消息:客户端发送到服务器端的东西，服务器端需要接住然后判断我们请求的是什么，才能进行响应

目的:为了学习全栈开发而准备协议名://域名:端口号/路由?请求消息

#### 2、作用：跳转

location="新url"跳转后禁止后退:

location.replace("新url");刷新: 

location.reload();

### 4、*****event对象

事件:用户触发的或浏览器自动触发的(onload)

#### 1、绑定事件:3种

##### 1、在HTML页面上绑定事件

```
<elem on事件名="js语句"></elem>
```

缺点:
1、不符合内容(html)与样式(css）与行为js)的分离的原则

2、无法动态绑定事件(一次只能绑定一个元素)

3、无法同时绑定多个函数对象

##### 2、在js种使用元素的事件处理函数属性

```
elem.on事件名=function(){
	操作
}
```

优点:
1、符合内容(html)与样式(css)与行为(js）的分离的原则

2、动态绑定事件

3、没有兼容性问题

缺点：
1、无法同时绑定多个函数对象 

##### 3、使用专门的事件API绑定事件

```
主流: elem.addEventListener("事件名" ,callback);
老IE: elem.attachEvent("on事件名" ,callback);
兼容:if(elem.addEventListener){
elem.addEventListener(“事件名" ,callback);
}else{
elem.attachEvent("on事件名",callback);

```

优点:
1、符合内容(html)与样式(css）与行为js)的分离的原则

2、动态绑定事件(一次只能绑定一个元素)

3、同时绑定多个函数对象

缺点：
1、具有兼容性问题

### 2、事件周期

主流:3个阶段
1、捕获阶段，记录着要发生的事件有哪些
2、目标元素优先触发，目标元素→实际触发事件的元素

3、冒泡触发，向上触发所有的记录着的事件

老IE:2个阶段，没有捕获阶段

### 3、*****获取事件对象event:

主流:会自动作为事件处理函数的第一个形参传入

```
elem.on事件名=function(e){e-event}
```

老IE: event;

```
兼容:var e=event; //不光老IE可用，主流也可以用
```

**获取到event事件对象，我们可以干什么?

#### 1、获取鼠标的坐标/位置

#### 2、阻止冒泡

```
主流: e.stopPropagation()
老IE: e.cancelBubble=true;
兼容: e.cancelBubble=true;//不光老IE可用，主流也可以用-小三上位

```

#### 3、***事件委托/利用冒泡

–笔试面试开发中
优化:如果多个子元素定义了相同或相似的事件，最好只给父元素定义一次

为什么∶每次绑定一个事件函数，其实都是创建了一个事件对象，创建的事件对象越多，网站的性能越差

淘汰this:水性杨花，当前元素
认识一个目标元素:target:你点击的是哪一个，永远就是那一个

```
主流: e.target;
老IE: e.srcElement;
兼容:e.srcElement;//不光老IE可用，主流也可以用–小三上位
```

#### 4、***阻止浏览器的默认行为:

 a标签默认跳转页面，右键自带一个弹出框，F12打开一个控制台，F5会刷新

```
主流: e.preventDefault();
老IE: e.returnValue=false;
兼容: e.returnValue=false;//不光老IE可用，主流也可以用-小三上位
```

新事件:

```
window.oncontextmenu=()=>{//鼠标右键事件}
window.onkeydown[up]press=()=>{//键盘事件–我们不做游戏开发
}
```

5、获取键盘的键码:
e.keyCode; ===不需要去记忆键码，要么百度查看，要么直接输出查看

# Day044

1、学习原因:
1、前端的招聘要求–熟悉或了解一门服务器端语言者优先
2、对于我们前端来说，了解了服务器端的机制，更好更快的进行前端开发，防止背锅
扩展:
全栈工程师:客户端(PC+移动端+小程序)＋服务器端(Node.js)＋数据库(mongoDB)技术类发展:
全栈–涉及多个领域，每个领域都会用，但是不必精通->架构师->项目经理->技术总监专家–某个领域是无敌，你不光可以使用，你还会创建
销售类发展
产品-→产品经理->产品总监:必须要懂技术的，要懂开发/项目流程，出去和客户谈业务，每一个功能都是钱
教育类
创业类
可能成为全栈的语言:
1、Java -不包含移动端开发（能做安卓，不能做IOS)

2、JavaScript语言:

客户端–开发根本
服务器端– Node.js 历史上第一次一门语言可以通吃前后端，前端崛起的原因之一数据库- mongoDB
移动端·网页、app、小程序·跨平台开发，只需要一个前端，学一点点Andriod和lOS的语法，就可以搞定了，前端崛起的原因之一

server:对服务器端的掌握–入门，以后你自学也没问题
还得搭配上ajax，完成最终目标:全栈开发:登录、注册、图书/金夫人/咖啡管理系统（后台)

## 服务器基本内容

服务器概念:

简单来说就是一台电脑生活:微机

商业/国家中:小型机(造价几十万，好点的IBM的上百万)、中型机、大型机、超级计算机(天河一号、天河二号、神威太湖之光)

### 拥有服务器的方式

0、买小型机–对小公司遭不住

1、买一台配置好一点的微机

2、租云服务器–腾讯云、阿里云、百度云、新浪云...-配置自选，价格友好，按年收费...

对于我们开发人员来说：

硬件服务器–电脑

软件服务器–中间件（软件可以将你的电脑变成一台服务器，其他人都可以来访问)

软件架构:服务器端重不重要?

C/S - Client客户端/Server服务器端

举例:QQ

大型网络游戏优点:
运行稳定，用户体验感好，对带宽的要求低缺点:
占用硬盘空间更新过于麻烦

B/S - Browser浏览器端/Server服务器端

举例:
网页版QQ、微信网页游戏
优点:
几乎不占硬盘
更新只需要更新服务器端

缺点：体验感较差

## Node.js

### 概述

不是JS，但是语法和javascript非常相似，他的竞争对手java、c#、php、python.….历史上第一次一门语言可以通吃前后端

做的功能绝对不是特效，做事的是服务器端的操作（形成了一个前端和数据库沟通交流的桥梁–数据交互)目的:

1、使用代码搭建一个服务器&文件系统（放在代老师电脑上的HTML，你们也可以访问到，而且根据你访问的网址不同，看到的网页也是不同的)

2、Node.js如何和数据库进行交流沟通（在这之前肯定还要学习mongoDB)

3.全栈一条龙开发，图书管理系统(HTML+CSS+JS+NODE.js + mongoDB)

### 安装

Node,js安装: node-v16.17.0-x64.msi -一路往下点，哪里点不动了，就把哪里勾上，千万不要取消任何东西
版本:16年初(0.12)
16年中(4.x)16年底(6.xx)-更新速度快，意味着:发展迅速，其实也没加什么新东西，但是给你错觉，感觉一年要学好多次
检查自己安装成功没有:打开cmd，输入node -v检查版本号，如果有版本号说明已经在你的电脑里安装成功了node.js

### 如何运行

#### 1、交互模式–临时测试

打开cmd输入,node回车，就可以开始敲你的"js"代码了退出: ctrl+c

#### 2、脚本/文件模式– 正式开发中

1、创建xx.js:里面书写自己的代码2、打开cmd输入: node 文件绝对路径
3、现在我们的开发工具非常强大:有插件可以直接在开发工具中运行

#### 3、现在我们的开发工具非常强大

有插件可以直接在开发工具中运行，前提就以上两个操作可用，意味着你的环境是安装好了的
1、HBuilder:安装一个插件:nodeeclipse，右键运行
2、VScode:安装一个插件:搜索一个run，代码处右键，第一个选项就是runI

### 知识：

### 1、js和node的区别

相同点:都可以使用一切的ECMAScript的一切的API和语法都可以放心大胆的使用，服务器端根本不存在任何浏览器，所以一切语法放心用

不同点:1、javascript: DOM+BOM–做─切特效不同点：
2、Node.js:虽然不支持DOM+BOM，但是他却提供了10万个以上的模块等待我们学习

### 2、模块:每个.js文件，都可以称之为是一个模块

1、模块化开发方式:如果以一个电商网站来说，我可以按功能分为很多模块:商家模块、商品模块、产品模块、促销模块、用户模块..
分工合作，将每个模块交给对应的人完成，最后再由【主模块】进行引入

1、每个模块都有一个操作，可以公开/暴露自己的成员:

```
1、exports.属性名=值2.module.exports={

}
```

2、每个模块都有一个操作，可用于引入其他模块:

```
var xxx=require("./文件名"); -./在引入时是不可以省略的，但是文件后缀可以省略
```

##### [笔试题]：exports和module.exports有什么区别?

都是用于公开暴露自己的成员

但是:exports={}写法是错误的，为什么?

node.js的底层有一句话:exportsFmodule.exports

其实真正做公开功能的是module.exports如果你使用
exports={};覆盖了module.exports，不在具有公开功能

### 3、模块的分类:

1、官方模块–今/明天学习的重点，大概有20几个，重要的其实只有几个

2、第三方模块–多到数不清楚，提供了很多官方模块没有的东西，有一个网址npm可以去下载: mongo、express框架（简化)

3、自定义模块

### Node.js最大的特点:

1、快、非常快–以前最快的是php，Node.js的速度是php的14倍

2、为什么快:

​	1、因为官方模块提供的东西少，甚至连数据库操作都没有

​	2、使用google浏览器的v8引擎

### 4、官方模块∶

不需要下载，在你安装node,js环境的时候就已经安好了，但是某的模块需要引入，某的模块不用引入，就需要学习看文档

#### 1、*global模块:

全局模块–全局变量在所有模块中均可使用。

```
__dirname -当前文件夹得绝对路径
__filename -当前文件的完整绝对路径 
exports -一个空{}，公开和暴露自己得成员
module	-代指模块本身，包含其他4个变量
require() -一个函数，引入其他模块
```

#### 2、querystring模块:

查询字符串
需要引入: let qs = require('querystring');

提供了解析url的查询字符串部分的功能

```
var obj=qs.parse("查询字符串部分");
想要获取前端传来的某一个部分:obj.键名;
```

垃圾:只能解析查询字符串部分，如果前端传来的是一个完整的url网址，那他就解析不了

#### 3、url模块:网址模块–今日小重点

```
需要引入: let url = require('url');
提供了一些实用函数，用于完整的URL解析
var objUrl=url.parse("完整的url网址",true);

真正的重点:
1、查询字符串: objUrl.query.键名–拿到前端传到后端的东西
2、路由: objUrl.pathname;-判断路由的不同，响应不同的网页给用户看
```

#### 4、Buffer模块:

缓冲区，可以将数组变成一个16进制的数字

不需要我们去引入，可以直接使用

但是!我们绝对不会主动使用Buffer的任何操作，因为用了过后我们就不认识了，但是后面的一些AP可能会导致我们得到的结果直接就是Buffer

但是，也别怕，Node.js大部分的API其实是支持buffer操作,理解为，Buffer是Node.js提供的一种新的数据类型

#### 5、\*\*\*\*\*fs模块

FileSystem- 文件系统

需要引入: let fs = require('fs');

提供了可以操作文件的API

```
异步读取文件:
fs.readFile("绝对路径|文件路径",.(err,buf)= >{
拿到buf要干嘛?就需要写在这里
B)

异步写入文件:–将原来的东西，替换掉
fs.writeFile("绝对路径|文件路径","写入的新内容",(=>{
console.log(""写入完毕了，以后要做什么")
)

异步追加文件:-将原来的东西保留，替换掉
fs.appendFile("绝对路径|文件路径"∵"写入的新内容",0=>{
console.log("写入完毕了，以后要做什么")
})

```

#### 6、http模块

固定步骤：

```
//引入http、url、fs官方模块
var http=require("http");
var url=require("url");
var fs=require("fs");
//创建服务器
var app=http.createServer();
//为服务器设置监听的端口号
app.listen(80);//http默认端口为80，https默认端口为443
//为服务器绑定请求事件 - 请求？前端发到后端的，
app.on("request",(req,res)=>{
	//req - request:保存请求对象，请求对象，前端->后端，提供了一个属性req.url，解析此属性拿到自己需要的部分（路由|请求消息）
	var objUrl=url.parse(req.url,true);
	//得到前端传来路由部分
	var router=objUrl.pathname;
	//判断前端的路由是什么，给他返回不同的页面
	if(router=="/" || router=="/index.html"){
		//res - response：保存响应对象，后端->前端，提供了一个方法res.end(你想要响应的东西)
		fs.readFile("./public/index.html",(err,buf)=>{
			res.end(buf);
		})
	}else if(router.match(/html/)!=null){
		console.log(router);
		fs.readFile("./public"+router,(err,buf)=>{
			res.end(buf);
		})
	}else if(router.match(/css|js|jpg|png|gif|woff/)!=null){
		fs.readFile("./public"+router,(err,buf)=>{
			res.end(buf);
		})
	}
})
```

​		强调：
​			1、*****前端的一切action、href、src，所有引入路径的地方，全都被node.js当作了是一个路由请求，解析请求，读取对应的文件给用户看
​			2、自己想要访问自己，打开浏览器，可以使用127.0.0.1访问自己，访问别人（前提：防火墙关了没），需要别人把自己的ipv4地址给你，打开cmd，输入ipconfig

# Day045

## 1、模块(每个.js文件)分类:

1、官方模块: var xx=require("官方模块名")

2、第三方模块

3、自定义模块:2大类

为什么有的模块要引入时加上./，有的模块又不需要

1、文件模块:创建xx.js去公开需要公开的内容，主模块想要引入必须写为require("./文件名")

2、目录模块:3种

1、创建名为m1的文件夹，在其中创建index.js的文件，去需要公开的内容，主模块想要引入必须写为require("./文件夹的名字")

2、创建名为m2的文件夹，在其中创建xx.js的文件，去需要公开的内容，主模块想要引入必须写为require("./文件夹的名字")但是需要在m2文件夹中，在创建一个必须package.json的配置文件

3、创建一个必须名为node_modules的文件夹，在其中创建名为m3的文件夹，在其中创建indexjs的文件，去需要公开的内容，主模块想要引入必须写为require("./文件夹的名字")

其实真实开发中，我们程序员用的最多的就是文件模块，目录模块的第三种方式根本就不是人用的，是机器npm的使用的

## 2、npm: 

node package manager

 node的模块/包管理器:专门管理第三方模块的，作用:下载安装、删除、更新、维护包的依赖关系..
如何使用第三方模块:
1、打开网站: npm官网

2、搜索你需要用到的模块，尽量用带有完全符合标志的那个包

3、打开cmd:检查一下npm下载工具是否安装成功: npm -v

4、下载: npm i 包名

5、删除: npm un 包名

## 3、介绍一下数据

### 数据库产品

关系型数据库–以表格为主

Oracle - Oracle (甲骨文)
主要应用于【企业级】开发市场，企业级:大公司、国企、事业单位(银行、警察局)，不差钱的公司，安全性很高

MySQL - Oracle (甲骨文)
主要应用于【互联网】开发市场，安全性相对较低，但是免费的，中小型公司的首选，但是和Node.,js搭配不友好

sql server - 微软

非关系型数据库–没有固定的格式
	是一种运动–反关系型数据库

# Day046

## MongoDB基础：-以json

### 1、安装&启动mongo

​	1、解压代老师提供的mongodb-win32-x86_64-2008plus-ssl-3.6.11.zip文件

​	2、解压好了进入到bin文件夹: mongo.exe (客户端)和mongod.exe(服务器端)

​	3、如何启动：
​		打开命令行cmd或powershell都可以，但是路径不能有中文，输入：.\mongod.exe --dbpath=你想要的绝对路径地址–服务器启动成功,服务器开好不要关闭。

​		再打开一个命令行，输入:.\mongo.exe-再打开上一个服务器命令行看看是否连接成功–客户端开启成功

### 2、mongo语法：

-目前都是在客户端的命令行里面使用

#### 1、数据库操作

##### 1、查询数据库：

```
show  dbs
```

##### 2、创建/切换数据库:

```
use数据库名称;–如果是一个空的数据库，show dbs是查看不到的，至少要创建一个表
```

##### 3、查看当前选中的数据库:

```
db
```

##### 4、创建数据库:

```
db.createCollection("库名");
```

##### 5、删除数据库： -能忘了能忘了

```
db.dropDatabase()
```

#### 2、数据表操作

##### 1、创建数据表

```
db.createCollection("表名",{size:5242880,capped:true,max:5000});-第二个参数
```

##### 2、查看目前所有的数据表

```
db.getCollectionNames();
```

##### 3、删除数据表

```
db.表名.drop();
```

#### 3、数据操作

##### 1、增

```
db.表名.save({属性名:属性值,...}) -一次只能插入一条数据
```

举例：db.users.save({name:"hjf,age:18,pwd:"12313",eamil:"hjf@qq.com",vip:"0"})

```
db.表名.save([{},{},{}]) - 多条数据
```

##### 2、删

```
db.表名.remove({条件(键值对)})
```

举例：db.表名.remove({age:18})

##### 3、改

```
db.表名.update({条件},{要改的内容})
```

举例：db.表名.update({name:"paoge",pwd:"666666"},{age:18}) - 这句话会把名字为paoge和密码为666666的替换为只剩age为17

db.表名.update({name:"paoge",pwd:"666666"},{$set:{age:18}}) 

##### 4、查

```
db.表名.find() - 所有的
db.表名.find({age:18})–找到所有年龄为18的数据
db.表名.find({age:{$gte:18})-找到所有年龄大于等于18的数据
db.表名.find({name:/正则/)–甚至可以写入正则来进行模糊查询
db.表名.find({},{name:1,age:1})-只需要name和age，其他的不要，1和0相当于是开关
db.表名.find().sort({age:1}) -按照age升序排列，降序的话换为-1
db.表名.find().skip(5).limit(5)-跳过前5条，再拿5条，可以理解为5-10;
db.表名.find().count()–获取此表有多少条数据
```

### 1、安装mongoose第三方模块

#### 使用步骤：

​		1、引入：const mongoose = require('mongoose');
​		2、连接数据库：mongoose.connect('mongodb://127.0.0.1/数据库名称');
​		3、//创建出一个新的数据表的同时，设置数据类型的控制，防止用户恶意输入
​			var userSchema=mongoose.Schema({
​				name:String,
​				age:Number,
​				pwd:String,
​				email:String,
​				vip:String
​			})
​					//模型名首字母大写			//数据表名
​			var 模型名=mongoose.model("Users",userSchema,"users");
​		4、SQL语句上场了：
​			增：
​					var user=new 模型名({
​						name:"dy1",
​						age:"abc",
​						pwd:"123123",
​						email:"dy1@qq.com",
​						vip:"0"
​					})
​					user.save((err)=>{
​						console.log(err);//错误提示对象，null说明没有错误
​						//插入完毕后要干什么在这里写代码
​					})

			删：
					模型名.deleteOne/deleteMany({条件},(err)=>{
						//删除完毕后要干什么在这里写代码
					})
	
			改：
					模型名.updateOne/updateMany({条件},{新内容},(err)=>{
						//修改完毕后要干什么在这里写代码
					})
	
			查：- 重点
					模型名.find({条件},(err,result)=>{
						result;//查询到数据库中的东西
					})

## Ajax

### 概念

同步交互:用户向服务器端发起请求的时候，直到服务器进行响应的全过程，用户是不可以做其他事情的（等)
	典型:网址请求、表单请求–目前我们一直都在使用同步交互
异步交互:用户向服务器端发起请求的时候，直到服务器进行响应的全过程，用户是可以做其他事情的〈不等)
	典型:ajax请求



### 如何使用：4步骤

#### 1、创建ajax的核心对象XMLHttpRequest;

var xhr=new XMLHttpRequest();

#### 2、建立和服务器端的连接

xhr.open("GET","路由");

#### 3、向服务器端发送请求

xhr.send();

特殊:GET请求: xhr.send()会失效，但是还不能省略，必须写为xhr.send(null);请求消息需要放到路由后面

xhr.open("GET"."路由?key=value&key=value");

#### 4、绑定状态监听事件

xhr.onreadystatechange=(=>{
if(xhr.status==200&&xhr.readyState= =4){
var data=xhr.responseText; -拿到服务器端的数据要干什么
}
}

## XML数据格式

### 1、面试题  HTML\XHTML\DHTML\XML分别是什么

HTML-网页	

XHTML-更严格的网页	

DHTML-动态的网页 D：Dynamic 不是新技术、新概念，只是现有技术整合的统称，让我们的网页再离线版	HTML+css+JS(dom)

XML-配置文件|数据格式

### 2、如何使用XML

1、创建xx.xml文件
2、必须写上声明标签

```
<?xml version="1.0" encoding="utf-8"?>
```

version -版本号：目前的版本只有1.0和1.1，但是1.1升级的并不理想，所以市场上还是主流使用1.0版本

3、必须写上【一个】根标签，而且只能写一个根标签(标签)，没有任何的预定义标签，意味着你想写什么标签就写什么

4、里面随你，想放什么就放什么

案例：

```
<?xml version="1.0" encoding="utf-8"?>
<root>
	<people>
		<name>小花</name>
		<age>20</age>
	</people>
</root>
```

需要使用node.js去读取你存储好的xml文件，响应给前端，
前端依然使用ajax去访问node.js，接住响应的数据必须写为xhr.responseXML-得到的就是一个dom对象，可以使用核心DOM来进行解析

## 2、***JSON数据格式:

JavaScript Object Notation: js对象表示法，本身就是js的一部分

作用:数据格式类似XML 
优点:比XML更简洁、更快、更容易解析–一个优秀的数据格式/结构能极大的提升我们程序员的开发效率

属于【字符串】数据表示法
1、后端的操作：哪些数据JSON字符串:后端把数据库的数据取出来，整理为一个JSON字符串:
1、先要认识哪些叫做JSON字符串:

```
1、'[1,2,3,4,5]'
2、{"key":value}'
3、'[{},{},{}]'
4、"{"names":["代老师","冉老师","卢老师"]}'
```

2、怎么才能变为JSON字符串:

```
JSON.stringify(x);
```

2、前端:依然使用ajax去获取数据，但是真正重要的是xhr.responseText;
拿到JSON字符串并不方便我们获取数据，怎么脱衣服?
1、eval("("+jsonTxt+")");-只要外层 是{}，优先级就会出现问题，导致脱衣服报错

2、*JSON.parse(jsonTxt);

3、h5十大新特性：
	一、语义标签

二、增强型表单

三、视频和音频

四、Canvas绘图 - 数据可视化，比如饼状图，柱状图，曲线图... 有现成的框架，echars.js三阶段就会学习

五、SVG绘图 - 画小图标 - 我们画的丑，但是网上一大堆

六、拖拉API

七、WebWorker

八、WebStorage：客户端存储技术/前端存储技术：
	1、其实有两种：
		1、把数据放在location的查询字符串里面
		2、cookie技术：几乎淘汰了，解析方式非常麻烦，能存储的大小2kb
		3、WebStorage：使用起来简单快速，解析方便，能存储4mb
			作用：1、能在客户端存储数据
			          2、跨页面也能使用
			分两大类：
				1、sessionStorage - 会话级，浏览器一旦关闭数据就会死亡了
				2、localStorage     -  本地级，永久存储此数据

​			操作：xxxStorage是一个对象
​			    保存：xxxStorage.属性名=属性值;
​			    读取：xxxStorage.属性名
​			    删除：xxxStorage.removeItem("属性名");
​			    清空：xxxStorage.clear();

九、WebSocket

十、地理定位 - 百度/高德地图

GET:显示在url地址上，安全性低，大小优先2kb
		找别人那东西，跟安全性不挂钩:比如搜索框、ajax 
POST:安全高，大小无限制
只要跟安全性相关的，都用post:登录/注册

## Day051

### 1、为什么你们现在开发这么缓慢?

1、不够熟悉–解决:多敲多练，猛肝自然强

### 2、我们目前学习的所有的东西都需要自己纯手敲，我们学的都是原生的东西-最值钱

2、我们需要有各种各样的框架，目的:来简化开发
主要是三阶段: vue.js+react.js (2个8周)+uniapp+小程序
底层就是原生JavaScript，一定进行了简化开发，比如: vue和react提供了虚拟DOM
当今社会最流行的3大框架:
vue.js(国人自己开发，鱿鱼须开发的，借鉴了react和angular，三大框架中最简单)react.js
angular.js(北上广深杭:10家公司没有一家，重庆:20家没有一家，国外很多)

### 3、简单的插件库

#### 1、日期插件:

​	1、wdatepicker.js: -丑

```
	1、下载引入:<script src="My97DatePicker/WdatePicker.js" type="text/javascript" charset="utf-8"></script>

	2、书写js:
inp.onfocus=function(){
WdatePicker({
el:"inp"//el -> element你的日期选择器选择的元素是哪个
	//更多的键值对可以看源代码
});
}
```

2、layUI.js -组件库/框架/插件库
